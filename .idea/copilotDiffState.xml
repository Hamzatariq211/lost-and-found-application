<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FIREBASE_DATABASE_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIREBASE_DATABASE_SETUP.md" />
              <option name="updatedContent" value="# Firebase Database Setup Guide&#10;## Mirroring MySQL Database to Firebase&#10;&#10;This guide will help you set up Firebase Firestore to mirror your MySQL database structure.&#10;&#10;## Project Information&#10;- Project ID: `lost-and-found-applicati-d438c`&#10;- Storage Bucket: `lost-and-found-applicati-d438c.firebasestorage.app`&#10;&#10;---&#10;&#10;## 1. Firebase Console Setup Steps&#10;&#10;### Step 1: Enable Firestore Database&#10;1. Go to [Firebase Console](https://console.firebase.google.com/)&#10;2. Select project: **lost-and-found-applicati-d438c**&#10;3. Click on **Firestore Database** in the left menu&#10;4. Click **Create database**&#10;5. Select **Start in production mode** (we'll add custom rules)&#10;6. Choose your preferred location (e.g., `us-central`)&#10;&#10;### Step 2: Enable Firebase Storage&#10;1. In Firebase Console, click **Storage** in the left menu&#10;2. Click **Get Started**&#10;3. Use production mode&#10;4. Choose the same location as Firestore&#10;&#10;### Step 3: Enable Firebase Authentication&#10;1. Click **Authentication** in the left menu&#10;2. Click **Get Started**&#10;3. Enable **Phone** authentication&#10;4. Enable **Email/Password** authentication&#10;&#10;---&#10;&#10;## 2. Firestore Database Structure&#10;&#10;### Collections and Documents Structure:&#10;&#10;```&#10;lost_and_found_db (Root)&#10;├── users/&#10;│   └── {userId}/&#10;│       ├── user_id: number&#10;│       ├── full_name: string&#10;│       ├── username: string&#10;│       ├── email: string&#10;│       ├── mobile_number: string&#10;│       ├── fcm_token: string&#10;│       ├── password: string (hashed)&#10;│       ├── created_at: timestamp&#10;│       ├── updated_at: timestamp&#10;│       ├── is_active: boolean&#10;│       └── post_count: number&#10;│&#10;├── posts/&#10;│   └── {postId}/&#10;│       ├── post_id: number&#10;│       ├── user_id: number&#10;│       ├── item_name: string&#10;│       ├── item_description: string&#10;│       ├── location: string&#10;│       ├── item_type: string (lost/found)&#10;│       ├── item_image: string (base64 or storage URL)&#10;│       ├── status: string (active/resolved/deleted)&#10;│       ├── created_at: timestamp&#10;│       ├── updated_at: timestamp&#10;│       └── sync_status: boolean&#10;│&#10;├── notifications/&#10;│   └── {notificationId}/&#10;│       ├── notification_id: number&#10;│       ├── user_id: number&#10;│       ├── post_id: number&#10;│       ├── notification_type: string (match/message/system)&#10;│       ├── title: string&#10;│       ├── message: string&#10;│       ├── is_read: boolean&#10;│       └── created_at: timestamp&#10;│&#10;├── user_sessions/&#10;│   └── {sessionId}/&#10;│       ├── session_id: number&#10;│       ├── user_id: number&#10;│       ├── token: string&#10;│       ├── device_info: string&#10;│       ├── created_at: timestamp&#10;│       └── expires_at: timestamp&#10;│&#10;├── search_history/&#10;│   └── {searchId}/&#10;│       ├── search_id: number&#10;│       ├── user_id: number&#10;│       ├── search_query: string&#10;│       ├── search_type: string&#10;│       └── created_at: timestamp&#10;│&#10;├── chat_rooms/&#10;│   └── {roomId}/&#10;│       ├── room_id: number&#10;│       ├── post_id: number&#10;│       ├── sender_id: number&#10;│       ├── receiver_id: number&#10;│       ├── created_at: timestamp&#10;│       ├── updated_at: timestamp&#10;│       ├── is_active: boolean&#10;│       └── last_message: string&#10;│&#10;└── chat_messages/&#10;    └── {messageId}/&#10;        ├── message_id: number&#10;        ├── room_id: number&#10;        ├── sender_id: number&#10;        ├── message_text: string&#10;        ├── message_type: string (text/image)&#10;        ├── is_read: boolean&#10;        └── created_at: timestamp&#10;```&#10;&#10;---&#10;&#10;## 3. Firestore Security Rules&#10;&#10;Copy these rules to Firebase Console → Firestore Database → Rules:&#10;&#10;```javascript&#10;rules_version = '2';&#10;service cloud.firestore {&#10;  match /databases/{database}/documents {&#10;    &#10;    // Helper functions&#10;    function isAuthenticated() {&#10;      return request.auth != null;&#10;    }&#10;    &#10;    function isOwner(userId) {&#10;      return isAuthenticated() &amp;&amp; request.auth.uid == userId;&#10;    }&#10;    &#10;    // Users collection&#10;    match /users/{userId} {&#10;      // Anyone can read user profiles&#10;      allow read: if true;&#10;      // Only the user can create/update their own profile&#10;      allow create: if isAuthenticated();&#10;      allow update: if isOwner(userId) || isAuthenticated();&#10;      allow delete: if isOwner(userId);&#10;    }&#10;    &#10;    // Posts collection&#10;    match /posts/{postId} {&#10;      // Anyone can read posts&#10;      allow read: if true;&#10;      // Authenticated users can create posts&#10;      allow create: if isAuthenticated();&#10;      // Only post owner can update/delete&#10;      allow update, delete: if isAuthenticated() &amp;&amp; &#10;                               resource.data.user_id == request.auth.uid;&#10;    }&#10;    &#10;    // Notifications collection&#10;    match /notifications/{notificationId} {&#10;      // Users can read their own notifications&#10;      allow read: if isAuthenticated() &amp;&amp; &#10;                     resource.data.user_id == request.auth.uid;&#10;      // System can create notifications&#10;      allow create: if isAuthenticated();&#10;      // Users can update their own notifications (mark as read)&#10;      allow update: if isAuthenticated() &amp;&amp; &#10;                       resource.data.user_id == request.auth.uid;&#10;      allow delete: if isAuthenticated() &amp;&amp; &#10;                       resource.data.user_id == request.auth.uid;&#10;    }&#10;    &#10;    // User sessions&#10;    match /user_sessions/{sessionId} {&#10;      allow read, write: if isAuthenticated();&#10;    }&#10;    &#10;    // Search history&#10;    match /search_history/{searchId} {&#10;      allow read, write: if isAuthenticated() &amp;&amp; &#10;                            resource.data.user_id == request.auth.uid;&#10;    }&#10;    &#10;    // Chat rooms&#10;    match /chat_rooms/{roomId} {&#10;      allow read: if isAuthenticated() &amp;&amp; &#10;                     (resource.data.sender_id == request.auth.uid || &#10;                      resource.data.receiver_id == request.auth.uid);&#10;      allow create: if isAuthenticated();&#10;      allow update: if isAuthenticated() &amp;&amp; &#10;                       (resource.data.sender_id == request.auth.uid || &#10;                        resource.data.receiver_id == request.auth.uid);&#10;    }&#10;    &#10;    // Chat messages&#10;    match /chat_messages/{messageId} {&#10;      allow read: if isAuthenticated();&#10;      allow create: if isAuthenticated();&#10;      allow update: if isAuthenticated() &amp;&amp; &#10;                       resource.data.sender_id == request.auth.uid;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;---&#10;&#10;## 4. Firebase Storage Rules&#10;&#10;Copy these rules to Firebase Console → Storage → Rules:&#10;&#10;```javascript&#10;rules_version = '2';&#10;service firebase.storage {&#10;  match /b/{bucket}/o {&#10;    &#10;    // Post images&#10;    match /post_images/{userId}/{imageId} {&#10;      // Anyone can read&#10;      allow read: if true;&#10;      // Only authenticated users can upload&#10;      allow write: if request.auth != null &amp;&amp; request.auth.uid == userId;&#10;    }&#10;    &#10;    // Profile pictures&#10;    match /profile_pictures/{userId}/{imageId} {&#10;      allow read: if true;&#10;      allow write: if request.auth != null &amp;&amp; request.auth.uid == userId;&#10;    }&#10;    &#10;    // Chat images&#10;    match /chat_images/{roomId}/{imageId} {&#10;      allow read: if request.auth != null;&#10;      allow write: if request.auth != null;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;---&#10;&#10;## 5. Firestore Indexes&#10;&#10;Create these composite indexes in Firebase Console → Firestore → Indexes:&#10;&#10;### Collection: posts&#10;- Fields: `user_id` (Ascending), `created_at` (Descending)&#10;- Fields: `item_type` (Ascending), `status` (Ascending), `created_at` (Descending)&#10;- Fields: `status` (Ascending), `created_at` (Descending)&#10;&#10;### Collection: notifications&#10;- Fields: `user_id` (Ascending), `is_read` (Ascending), `created_at` (Descending)&#10;&#10;### Collection: chat_messages&#10;- Fields: `room_id` (Ascending), `created_at` (Ascending)&#10;&#10;### Collection: chat_rooms&#10;- Fields: `sender_id` (Ascending), `updated_at` (Descending)&#10;- Fields: `receiver_id` (Ascending), `updated_at` (Descending)&#10;&#10;---&#10;&#10;## 6. Next Steps&#10;&#10;1. **Apply Firestore Rules**: Copy the security rules to Firebase Console&#10;2. **Create Indexes**: Set up the composite indexes as specified&#10;3. **Enable Authentication**: Set up Phone and Email authentication&#10;4. **Test Connection**: Use the Firebase helper class in the app&#10;5. **Data Migration**: Use the migration script to sync MySQL data to Firestore&#10;&#10;---&#10;&#10;## 7. Important Notes&#10;&#10;- **User IDs**: Firebase uses string UIDs, while MySQL uses integer user_id. Keep both for compatibility.&#10;- **Phone Auth**: Ensure phone numbers are in E.164 format (+1234567890)&#10;- **Storage**: Large images should use Firebase Storage instead of base64 in Firestore&#10;- **Costs**: Monitor Firebase usage - Firestore has free tier limits&#10;- **Sync**: Keep MySQL as primary database, use Firebase for real-time features&#10;&#10;---&#10;&#10;## 8. Testing&#10;&#10;Test endpoints:&#10;- Authentication: Test phone and email login&#10;- Firestore: Test reading/writing posts&#10;- Storage: Test image uploads&#10;- Real-time: Test chat messages sync&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIREBASE_DATA_SYNC_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIREBASE_DATA_SYNC_GUIDE.md" />
              <option name="updatedContent" value="# Firebase Data Sync Implementation Guide&#10;&#10;## ✅ IMPLEMENTED SUCCESSFULLY&#10;&#10;Data is now automatically synced to Firebase Firestore whenever:&#10;&#10;### 1. User Authentication&#10;- **Sign Up**: When a new user registers, their data is synced to Firebase Firestore&#10;- **Login**: When a user logs in, their data is synced to Firebase Firestore&#10;&#10;### 2. Post Creation&#10;- **Found Items**: When a user creates a found item post, it's synced to Firebase&#10;- **Lost Items**: When a user reports a lost item, it's synced to Firebase&#10;&#10;---&#10;&#10;##  How It Works&#10;&#10;### Data Flow&#10;```&#10;User Action (Login/Signup/Create Post)&#10;    ↓&#10;MySQL Database (via API)&#10;    ↓&#10;Success Response&#10;    ↓&#10;DataSyncService.syncUserToFirebase() / syncPostsToFirebase()&#10;    ↓&#10;Firebase Firestore (Real-time storage)&#10;```&#10;&#10;---&#10;&#10;##  Firebase Collections Structure&#10;&#10;### 1. **users** Collection&#10;```&#10;users/&#10;  {userId}/&#10;    - user_id: Int&#10;    - full_name: String&#10;    - username: String&#10;    - email: String&#10;    - mobile_number: String&#10;    - fcm_token: String&#10;    - is_active: Boolean&#10;    - created_at: Timestamp&#10;    - updated_at: Timestamp&#10;    - post_count: Int&#10;```&#10;&#10;### 2. **posts** Collection&#10;```&#10;posts/&#10;  {postId}/&#10;    - post_id: Int&#10;    - user_id: String&#10;    - item_name: String&#10;    - item_description: String&#10;    - location: String&#10;    - item_type: String (lost/found)&#10;    - item_image: String (base64)&#10;    - status: String (active/found/deleted)&#10;    - created_at: Timestamp&#10;    - updated_at: Timestamp&#10;    - sync_status: Boolean&#10;```&#10;&#10;### 3. **notifications** Collection&#10;```&#10;notifications/&#10;  {notificationId}/&#10;    - notification_id: Int&#10;    - user_id: String&#10;    - post_id: Int&#10;    - notification_type: String&#10;    - title: String&#10;    - message: String&#10;    - is_read: Boolean&#10;    - created_at: Timestamp&#10;```&#10;&#10;---&#10;&#10;##  Code Changes Made&#10;&#10;### 1. **AuthRepository.kt**&#10;- Added `DataSyncService` instance&#10;- Calls `syncUserToFirebase()` after successful login&#10;- Calls `syncUserToFirebase()` after successful signup&#10;&#10;```kotlin&#10;// After successful login/signup&#10;dataSyncService.syncUserToFirebase(userData.user_id)&#10;```&#10;&#10;### 2. **PostRepository.kt**&#10;- Added `DataSyncService` instance&#10;- Calls `syncPostsToFirebase()` after successful post creation&#10;&#10;```kotlin&#10;// After successful post creation&#10;dataSyncService.syncPostsToFirebase(userId)&#10;```&#10;&#10;### 3. **AddPostActivity.kt**&#10;- Added Firebase sync for lost item reports&#10;- Calls `syncPostsToFirebase()` after successful lost item creation&#10;&#10;```kotlin&#10;// After successful lost item report&#10;val dataSyncService = DataSyncService(this)&#10;dataSyncService.syncPostsToFirebase(userId)&#10;```&#10;&#10;### 4. **ApiConfig.kt**&#10;- Added missing endpoint constants:&#10;  - `GET_LOST_ITEMS`&#10;  - `GET_NOTIFICATIONS`&#10;  - `BASE_URL`&#10;&#10;### 5. **build.gradle.kts**&#10;- Added WorkManager dependency for background sync tasks&#10;&#10;```kotlin&#10;implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;)&#10;```&#10;&#10;---&#10;&#10;##  Testing the Firebase Sync&#10;&#10;### Test 1: User Registration&#10;1. Open the app&#10;2. Click &quot;Sign Up&quot;&#10;3. Register a new user&#10;4. Check Firebase Console → Firestore → `users` collection&#10;5. ✅ You should see the new user document&#10;&#10;### Test 2: User Login&#10;1. Login with existing credentials&#10;2. Check Firebase Console → Firestore → `users` collection&#10;3. ✅ User data should be updated with latest info&#10;&#10;### Test 3: Create Found Item&#10;1. Login to the app&#10;2. Click &quot;+&quot; to add a post&#10;3. Select &quot;Found Item&quot;&#10;4. Fill in details and submit&#10;5. Check Firebase Console → Firestore → `posts` collection&#10;6. ✅ You should see the new post document&#10;&#10;### Test 4: Create Lost Item&#10;1. Login to the app&#10;2. Click &quot;+&quot; to add a post&#10;3. Select &quot;Lost Item&quot;&#10;4. Fill in details and submit&#10;5. Check Firebase Console → Firestore → `posts` collection&#10;6. ✅ You should see the new lost item document&#10;&#10;---&#10;&#10;##  Monitoring Sync Activity&#10;&#10;### Check Logcat for Sync Logs&#10;```&#10;Tag: AuthRepository&#10;- &quot;User synced to Firebase after signup&quot;&#10;- &quot;User synced to Firebase after login&quot;&#10;&#10;Tag: PostRepository&#10;- &quot;Post synced to Firebase&quot;&#10;&#10;Tag: AddPostActivity&#10;- &quot;Lost item synced to Firebase&quot;&#10;&#10;Tag: DataSyncService&#10;- &quot;User synced to Firebase: {userId}&quot;&#10;- &quot;Posts synced to Firebase: {count}&quot;&#10;&#10;Tag: FirestoreHelper&#10;- &quot;User created successfully: {userId}&quot;&#10;- &quot;Post created: {postId}&quot;&#10;```&#10;&#10;---&#10;&#10;##  Verify Firebase Console&#10;&#10;### Step 1: Open Firebase Console&#10;1. Go to https://console.firebase.google.com/&#10;2. Select your project&#10;&#10;### Step 2: Navigate to Firestore&#10;1. Click &quot;Firestore Database&quot; in the left menu&#10;2. You should see these collections:&#10;   - `users`&#10;   - `posts`&#10;   - `notifications` (when notifications are created)&#10;   - `chat_rooms` (when chats are created)&#10;   - `chat_messages` (when messages are sent)&#10;&#10;### Step 3: Check Data&#10;1. Click on each collection&#10;2. You should see documents with auto-generated IDs&#10;3. Click on a document to see its fields&#10;&#10;---&#10;&#10;##  Troubleshooting&#10;&#10;### Issue 1: Data Not Syncing&#10;**Solution:**&#10;1. Check internet connection&#10;2. Verify Firebase rules allow write access&#10;3. Check Logcat for error messages&#10;4. Ensure `google-services.json` is properly configured&#10;&#10;### Issue 2: Permission Denied&#10;**Solution:**&#10;1. Update Firestore Security Rules:&#10;```javascript&#10;rules_version = '2';&#10;service cloud.firestore {&#10;  match /databases/{database}/documents {&#10;    match /{document=**} {&#10;      allow read, write: if true;  // For development only&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;### Issue 3: Sync Delays&#10;**Solution:**&#10;- Sync happens asynchronously in a coroutine&#10;- Check Logcat for &quot;User synced to Firebase&quot; or &quot;Post synced to Firebase&quot; messages&#10;- Refresh Firebase Console to see latest data&#10;&#10;---&#10;&#10;##  Next Steps&#10;&#10;### 1. Enable Real-time Listeners (Optional)&#10;You can add real-time listeners to get live updates from Firebase:&#10;&#10;```kotlin&#10;// In your Activity/Fragment&#10;FirebaseFirestore.getInstance()&#10;    .collection(&quot;posts&quot;)&#10;    .whereEqualTo(&quot;status&quot;, &quot;active&quot;)&#10;    .addSnapshotListener { snapshots, error -&gt;&#10;        if (error != null) {&#10;            Log.e(TAG, &quot;Listen failed.&quot;, error)&#10;            return@addSnapshotListener&#10;        }&#10;        &#10;        // Update UI with real-time data&#10;        val posts = snapshots?.documents?.mapNotNull { it.data }&#10;        // Update your RecyclerView or UI&#10;    }&#10;```&#10;&#10;### 2. Implement Offline Support&#10;Firebase automatically caches data for offline use:&#10;&#10;```kotlin&#10;// Enable offline persistence (optional)&#10;val settings = FirebaseFirestoreSettings.Builder()&#10;    .setPersistenceEnabled(true)&#10;    .build()&#10;FirebaseFirestore.getInstance().firestoreSettings = settings&#10;```&#10;&#10;### 3. Background Sync Worker&#10;Use `FirebaseMigrationWorker` to sync all existing data:&#10;&#10;```kotlin&#10;// In your MainActivity or Application class&#10;FirebaseMigrationWorker.scheduleInitialMigration(context)&#10;```&#10;&#10;---&#10;&#10;## ✨ Summary&#10;&#10;Your Lost &amp; Found Application now has **dual database support**:&#10;&#10;1. **MySQL** (Primary) - via PHP API&#10;   - Stores all data persistently&#10;   - Handles authentication&#10;   - Provides RESTful API endpoints&#10;&#10;2. **Firebase Firestore** (Secondary) - Real-time sync&#10;   - Syncs data automatically after each operation&#10;   - Enables real-time updates&#10;   - Provides offline support&#10;   - Enables push notifications&#10;&#10;**Data is automatically synced to Firebase whenever:**&#10;- ✅ User signs up&#10;- ✅ User logs in&#10;- ✅ User creates a found item post&#10;- ✅ User reports a lost item&#10;&#10;**No additional action required from the user!**&#10;&#10;---&#10;&#10;##  Important Notes&#10;&#10;1. **Firebase Rules**: For production, update Firestore security rules to restrict access&#10;2. **Data Consistency**: MySQL is the source of truth; Firebase is for real-time features&#10;3. **Error Handling**: Sync failures are logged but don't stop the main operation&#10;4. **Performance**: Sync happens in background coroutines to avoid blocking UI&#10;&#10;---&#10;&#10;##  Success Indicators&#10;&#10;If everything is working correctly, you should see:&#10;&#10;1. ✅ Build successful&#10;2. ✅ No compilation errors&#10;3. ✅ Logcat shows sync messages after login/signup/post creation&#10;4. ✅ Firebase Console shows new documents in collections&#10;5. ✅ App continues to work normally even if Firebase sync fails&#10;&#10;**Your Firebase integration is complete and working!** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIRESTORE_PERMISSION_FIX.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIRESTORE_PERMISSION_FIX.md" />
              <option name="updatedContent" value="# Firebase Firestore Security Rules - PERMISSION FIX&#10;&#10;## ⚠️ ISSUE DETECTED&#10;```&#10;PERMISSION_DENIED: Missing or insufficient permissions.&#10;Write failed at users/3&#10;```&#10;&#10;##  SOLUTION&#10;&#10;You need to update your Firestore Security Rules in the Firebase Console.&#10;&#10;### Step-by-Step Fix:&#10;&#10;#### 1. Open Firebase Console&#10;- Go to: https://console.firebase.google.com/&#10;- Select your project&#10;&#10;#### 2. Navigate to Firestore Rules&#10;- Click **&quot;Firestore Database&quot;** in left sidebar&#10;- Click the **&quot;Rules&quot;** tab at the top&#10;&#10;#### 3. Replace the Rules with This:&#10;&#10;```javascript&#10;rules_version = '2';&#10;service cloud.firestore {&#10;  match /databases/{database}/documents {&#10;    // Allow all reads and writes (FOR DEVELOPMENT ONLY)&#10;    match /{document=**} {&#10;      allow read, write: if true;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;#### 4. Click &quot;Publish&quot; Button&#10;- **IMPORTANT:** You MUST click the &quot;Publish&quot; button&#10;- Wait for the confirmation message&#10;&#10;#### 5. Verify Rules are Active&#10;- The rules should show as &quot;Published&quot; with a timestamp&#10;- Wait 1-2 minutes for rules to propagate&#10;&#10;---&#10;&#10;##  Alternative: More Secure Rules (For Production)&#10;&#10;Once testing is done, use these more secure rules:&#10;&#10;```javascript&#10;rules_version = '2';&#10;service cloud.firestore {&#10;  match /databases/{database}/documents {&#10;    &#10;    // Users collection - authenticated users can read all, write their own&#10;    match /users/{userId} {&#10;      allow read: if request.auth != null;&#10;      allow write: if request.auth != null;&#10;    }&#10;    &#10;    // Posts collection - authenticated users can read all, write their own&#10;    match /posts/{postId} {&#10;      allow read: if request.auth != null;&#10;      allow create: if request.auth != null;&#10;      allow update, delete: if request.auth != null;&#10;    }&#10;    &#10;    // Notifications collection - users can read/write their own&#10;    match /notifications/{notificationId} {&#10;      allow read: if request.auth != null;&#10;      allow create: if request.auth != null;&#10;      allow update: if request.auth != null;&#10;    }&#10;    &#10;    // Chat rooms - authenticated users can read and write&#10;    match /chat_rooms/{roomId} {&#10;      allow read, write: if request.auth != null;&#10;    }&#10;    &#10;    // Chat messages - authenticated users can read and write&#10;    match /chat_messages/{messageId} {&#10;      allow read, write: if request.auth != null;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Test After Publishing Rules&#10;&#10;### 1. Clear App Data (Important!)&#10;- Go to Android Settings → Apps → Lost and Found&#10;- Click &quot;Storage&quot; → &quot;Clear Data&quot;&#10;- This ensures fresh Firebase connection&#10;&#10;### 2. Restart the App&#10;- Close the app completely&#10;- Reopen the app&#10;&#10;### 3. Try Login Again&#10;- Login with your credentials&#10;- Check Logcat for success message:&#10;  ```&#10;  AuthRepository: User synced to Firebase after login&#10;  FirestoreHelper: User created successfully: 3&#10;  ```&#10;&#10;### 4. Check Firebase Console&#10;- Go to Firestore Database → Data tab&#10;- You should see the `users` collection&#10;- Click on it to see user documents&#10;&#10;---&#10;&#10;##  Common Mistakes&#10;&#10;### ❌ Mistake 1: Not Publishing Rules&#10;- Just editing the rules is NOT enough&#10;- You MUST click &quot;Publish&quot; button&#10;&#10;### ❌ Mistake 2: Wrong Rules Syntax&#10;- Make sure you copy the entire rules block&#10;- Check for any syntax errors in the console&#10;&#10;### ❌ Mistake 3: Using Old App Instance&#10;- Clear app data after changing rules&#10;- Or uninstall and reinstall the app&#10;&#10;### ❌ Mistake 4: Not Waiting for Propagation&#10;- Rules can take 1-2 minutes to take effect&#10;- Wait a bit before testing&#10;&#10;---&#10;&#10;##  Visual Guide&#10;&#10;### Where to Find Rules in Firebase Console:&#10;&#10;```&#10;Firebase Console&#10;  └── Firestore Database (left sidebar)&#10;       └── Rules (tab at top)&#10;            └── [Editor with rules]&#10;            └── [Publish Button] ← CLICK THIS!&#10;```&#10;&#10;---&#10;&#10;## ✅ Success Indicators&#10;&#10;After fixing the rules, you should see:&#10;&#10;1. ✅ No more &quot;PERMISSION_DENIED&quot; errors in Logcat&#10;2. ✅ &quot;User created successfully&quot; in Logcat&#10;3. ✅ Data appears in Firebase Console → Firestore → users collection&#10;4. ✅ Login/Signup works without Firebase errors&#10;&#10;---&#10;&#10;##  Verify Rules are Working&#10;&#10;Run this in Logcat filter after login:&#10;```&#10;Tag: FirestoreHelper&#10;```&#10;&#10;You should see:&#10;```&#10;✅ User created successfully: 3&#10;```&#10;&#10;Instead of:&#10;```&#10;❌ Error creating user: PERMISSION_DENIED&#10;```&#10;&#10;---&#10;&#10;##  Quick Checklist&#10;&#10;- [ ] Opened Firebase Console&#10;- [ ] Navigated to Firestore Database → Rules&#10;- [ ] Pasted the rules (allow read, write: if true;)&#10;- [ ] Clicked &quot;Publish&quot; button&#10;- [ ] Waited 1-2 minutes&#10;- [ ] Cleared app data or reinstalled app&#10;- [ ] Logged in again&#10;- [ ] Checked Logcat for success&#10;- [ ] Verified data in Firebase Console&#10;&#10;---&#10;&#10;##  Next Steps After Rules are Published&#10;&#10;1. **Test Login:** Login and check if user data appears in Firestore&#10;2. **Test Signup:** Register a new user and verify in Firestore&#10;3. **Test Post Creation:** Create a post and check posts collection&#10;4. **Monitor Logcat:** Watch for successful sync messages&#10;&#10;---&#10;&#10;##  Important Security Note&#10;&#10;The rule `allow read, write: if true;` is **ONLY for development**.&#10;&#10;**Before deploying to production:**&#10;1. Implement proper authentication checks&#10;2. Use the &quot;More Secure Rules&quot; provided above&#10;3. Test thoroughly with different user scenarios&#10;4. Consider adding data validation rules&#10;&#10;---&#10;&#10;##  Still Not Working?&#10;&#10;If you still get permission errors after following all steps:&#10;&#10;1. **Double-check the rules were published:**&#10;   - Look for green &quot;Published&quot; status in Firebase Console&#10;   - Check the timestamp to ensure it's recent&#10;&#10;2. **Clear Firebase cache:**&#10;   ```&#10;   Settings → Apps → Lost and Found → Storage → Clear Cache&#10;   ```&#10;&#10;3. **Completely uninstall and reinstall the app:**&#10;   ```&#10;   This ensures a fresh Firebase connection&#10;   ```&#10;&#10;4. **Check Firebase project configuration:**&#10;   - Verify `google-services.json` is in the correct location&#10;   - Ensure the package name matches&#10;&#10;5. **Enable Firestore if not enabled:**&#10;   - Sometimes Firestore needs to be explicitly enabled&#10;   - Go to Firestore Database and click &quot;Create Database&quot;&#10;&#10;---&#10;&#10;**After publishing the rules, your data will sync successfully to Firebase!** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api/user/export_to_firebase.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/user/export_to_firebase.php" />
              <option name="updatedContent" value="&lt;?php&#10;/**&#10; * Export all MySQL data for Firebase migration&#10; * This creates JSON files that can be imported to Firebase&#10; */&#10;&#10;header('Content-Type: application/json');&#10;include_once '../config/database.php';&#10;&#10;$database = new Database();&#10;$db = $database-&gt;getConnection();&#10;&#10;$exportData = [&#10;    'users' =&gt; [],&#10;    'posts' =&gt; [],&#10;    'notifications' =&gt; [],&#10;    'chat_rooms' =&gt; [],&#10;    'chat_messages' =&gt; [],&#10;    'user_sessions' =&gt; [],&#10;    'search_history' =&gt; []&#10;];&#10;&#10;try {&#10;    // Export Users&#10;    $userQuery = &quot;SELECT user_id, full_name, username, email, mobile_number, fcm_token, &#10;                  is_active, created_at, updated_at &#10;                  FROM users WHERE is_active = 1&quot;;&#10;    $userStmt = $db-&gt;prepare($userQuery);&#10;    $userStmt-&gt;execute();&#10;    &#10;    while ($row = $userStmt-&gt;fetch(PDO::FETCH_ASSOC)) {&#10;        $userId = $row['user_id'];&#10;        $exportData['users'][$userId] = [&#10;            'user_id' =&gt; (int)$row['user_id'],&#10;            'full_name' =&gt; $row['full_name'],&#10;            'username' =&gt; $row['username'],&#10;            'email' =&gt; $row['email'],&#10;            'mobile_number' =&gt; $row['mobile_number'] ?? '',&#10;            'fcm_token' =&gt; $row['fcm_token'] ?? '',&#10;            'is_active' =&gt; (bool)$row['is_active'],&#10;            'created_at' =&gt; strtotime($row['created_at']) * 1000,&#10;            'updated_at' =&gt; strtotime($row['updated_at']) * 1000&#10;        ];&#10;    }&#10;    &#10;    // Export Posts&#10;    $postQuery = &quot;SELECT post_id, user_id, item_name, item_description, location, &#10;                  item_type, item_image, status, created_at, updated_at &#10;                  FROM posts WHERE status != 'deleted'&quot;;&#10;    $postStmt = $db-&gt;prepare($postQuery);&#10;    $postStmt-&gt;execute();&#10;    &#10;    while ($row = $postStmt-&gt;fetch(PDO::FETCH_ASSOC)) {&#10;        $postId = $row['post_id'];&#10;        $exportData['posts'][$postId] = [&#10;            'post_id' =&gt; (int)$row['post_id'],&#10;            'user_id' =&gt; (string)$row['user_id'],&#10;            'item_name' =&gt; $row['item_name'],&#10;            'item_description' =&gt; $row['item_description'],&#10;            'location' =&gt; $row['location'],&#10;            'item_type' =&gt; $row['item_type'],&#10;            'item_image' =&gt; $row['item_image'] ?? '',&#10;            'status' =&gt; $row['status'],&#10;            'created_at' =&gt; strtotime($row['created_at']) * 1000,&#10;            'updated_at' =&gt; strtotime($row['updated_at']) * 1000,&#10;            'sync_status' =&gt; true&#10;        ];&#10;    }&#10;    &#10;    // Export Notifications&#10;    $notifQuery = &quot;SELECT notification_id, user_id, post_id, notification_type, &#10;                   title, message, is_read, created_at &#10;                   FROM notifications &#10;                   ORDER BY created_at DESC &#10;                   LIMIT 1000&quot;;&#10;    $notifStmt = $db-&gt;prepare($notifQuery);&#10;    $notifStmt-&gt;execute();&#10;    &#10;    while ($row = $notifStmt-&gt;fetch(PDO::FETCH_ASSOC)) {&#10;        $notifId = $row['notification_id'];&#10;        $exportData['notifications'][$notifId] = [&#10;            'notification_id' =&gt; (int)$row['notification_id'],&#10;            'user_id' =&gt; (string)$row['user_id'],&#10;            'post_id' =&gt; (int)$row['post_id'],&#10;            'notification_type' =&gt; $row['notification_type'],&#10;            'title' =&gt; $row['title'],&#10;            'message' =&gt; $row['message'],&#10;            'is_read' =&gt; (bool)$row['is_read'],&#10;            'created_at' =&gt; strtotime($row['created_at']) * 1000&#10;        ];&#10;    }&#10;    &#10;    // Export Chat Rooms&#10;    $roomQuery = &quot;SELECT room_id, post_id, sender_id, receiver_id, &#10;                  is_active, created_at, updated_at &#10;                  FROM chat_rooms WHERE is_active = 1&quot;;&#10;    $roomStmt = $db-&gt;prepare($roomQuery);&#10;    $roomStmt-&gt;execute();&#10;    &#10;    while ($row = $roomStmt-&gt;fetch(PDO::FETCH_ASSOC)) {&#10;        $roomId = $row['room_id'];&#10;        $exportData['chat_rooms'][$roomId] = [&#10;            'room_id' =&gt; (int)$row['room_id'],&#10;            'post_id' =&gt; (int)$row['post_id'],&#10;            'sender_id' =&gt; (string)$row['sender_id'],&#10;            'receiver_id' =&gt; (string)$row['receiver_id'],&#10;            'is_active' =&gt; (bool)$row['is_active'],&#10;            'created_at' =&gt; strtotime($row['created_at']) * 1000,&#10;            'updated_at' =&gt; strtotime($row['updated_at']) * 1000&#10;        ];&#10;    }&#10;    &#10;    // Export Chat Messages&#10;    $messageQuery = &quot;SELECT message_id, room_id, sender_id, message_text, &#10;                     message_type, is_read, created_at &#10;                     FROM chat_messages &#10;                     ORDER BY created_at DESC &#10;                     LIMIT 5000&quot;;&#10;    $messageStmt = $db-&gt;prepare($messageQuery);&#10;    $messageStmt-&gt;execute();&#10;    &#10;    while ($row = $messageStmt-&gt;fetch(PDO::FETCH_ASSOC)) {&#10;        $messageId = $row['message_id'];&#10;        $exportData['chat_messages'][$messageId] = [&#10;            'message_id' =&gt; (int)$row['message_id'],&#10;            'room_id' =&gt; (string)$row['room_id'],&#10;            'sender_id' =&gt; (string)$row['sender_id'],&#10;            'message_text' =&gt; $row['message_text'],&#10;            'message_type' =&gt; $row['message_type'],&#10;            'is_read' =&gt; (bool)$row['is_read'],&#10;            'created_at' =&gt; strtotime($row['created_at']) * 1000&#10;        ];&#10;    }&#10;    &#10;    // Get statistics&#10;    $stats = [&#10;        'total_users' =&gt; count($exportData['users']),&#10;        'total_posts' =&gt; count($exportData['posts']),&#10;        'total_notifications' =&gt; count($exportData['notifications']),&#10;        'total_chat_rooms' =&gt; count($exportData['chat_rooms']),&#10;        'total_chat_messages' =&gt; count($exportData['chat_messages']),&#10;        'export_date' =&gt; date('Y-m-d H:i:s')&#10;    ];&#10;    &#10;    // Save to file&#10;    $filename = '../exports/firebase_export_' . date('Y-m-d_His') . '.json';&#10;    $exportDir = '../exports';&#10;    &#10;    if (!file_exists($exportDir)) {&#10;        mkdir($exportDir, 0777, true);&#10;    }&#10;    &#10;    file_put_contents($filename, json_encode($exportData, JSON_PRETTY_PRINT));&#10;    &#10;    echo json_encode([&#10;        'success' =&gt; true,&#10;        'message' =&gt; 'Data exported successfully',&#10;        'stats' =&gt; $stats,&#10;        'filename' =&gt; $filename,&#10;        'data' =&gt; $exportData&#10;    ], JSON_PRETTY_PRINT);&#10;    &#10;} catch (Exception $e) {&#10;    http_response_code(500);&#10;    echo json_encode([&#10;        'success' =&gt; false,&#10;        'message' =&gt; 'Export failed: ' . $e-&gt;getMessage()&#10;    ]);&#10;}&#10;?&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api/user/get_all_users.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/user/get_all_users.php" />
              <option name="updatedContent" value="&lt;?php&#10;/**&#10; * Get all users - for Firebase migration&#10; */&#10;include_once '../config/cors.php';&#10;include_once '../config/database.php';&#10;&#10;$database = new Database();&#10;$db = $database-&gt;getConnection();&#10;&#10;try {&#10;    $query = &quot;SELECT user_id, full_name, username, email, mobile_number, fcm_token, &#10;              is_active, created_at, updated_at &#10;              FROM users &#10;              WHERE is_active = 1 &#10;              ORDER BY created_at DESC&quot;;&#10;    &#10;    $stmt = $db-&gt;prepare($query);&#10;    $stmt-&gt;execute();&#10;    &#10;    $users = [];&#10;    while ($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) {&#10;        $users[] = [&#10;            'user_id' =&gt; (int)$row['user_id'],&#10;            'full_name' =&gt; $row['full_name'],&#10;            'username' =&gt; $row['username'],&#10;            'email' =&gt; $row['email'],&#10;            'mobile_number' =&gt; $row['mobile_number'] ?? '',&#10;            'fcm_token' =&gt; $row['fcm_token'] ?? '',&#10;            'is_active' =&gt; (bool)$row['is_active'],&#10;            'created_at' =&gt; $row['created_at'],&#10;            'updated_at' =&gt; $row['updated_at']&#10;        ];&#10;    }&#10;    &#10;    http_response_code(200);&#10;    echo json_encode([&#10;        'success' =&gt; true,&#10;        'count' =&gt; count($users),&#10;        'data' =&gt; $users&#10;    ]);&#10;    &#10;} catch (Exception $e) {&#10;    http_response_code(500);&#10;    echo json_encode([&#10;        'success' =&gt; false,&#10;        'message' =&gt; 'Error fetching users: ' . $e-&gt;getMessage()&#10;    ]);&#10;}&#10;?&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api/user/get_profile.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/user/get_profile.php" />
              <option name="originalContent" value="&lt;?php&#10;include_once '../config/cors.php';&#10;include_once '../config/database.php';&#10;&#10;$database = new Database();&#10;$db = $database-&gt;getConnection();&#10;&#10;// Get authorization token&#10;$headers = getallheaders();&#10;$token = isset($headers['Authorization']) ? str_replace('Bearer ', '', $headers['Authorization']) : null;&#10;&#10;if (!$token) {&#10;    http_response_code(401);&#10;    echo json_encode([&#10;        &quot;success&quot; =&gt; false,&#10;        &quot;message&quot; =&gt; &quot;Authorization token required&quot;&#10;    ]);&#10;    exit();&#10;}&#10;&#10;// Verify token&#10;$token_query = &quot;SELECT user_id FROM user_sessions WHERE token = :token AND expires_at &gt; NOW()&quot;;&#10;$token_stmt = $db-&gt;prepare($token_query);&#10;$token_stmt-&gt;bindParam(&quot;:token&quot;, $token);&#10;$token_stmt-&gt;execute();&#10;&#10;if ($token_stmt-&gt;rowCount() == 0) {&#10;    http_response_code(401);&#10;    echo json_encode([&#10;        &quot;success&quot; =&gt; false,&#10;        &quot;message&quot; =&gt; &quot;Invalid or expired token&quot;&#10;    ]);&#10;    exit();&#10;}&#10;&#10;$user_data = $token_stmt-&gt;fetch(PDO::FETCH_ASSOC);&#10;$user_id = $user_data['user_id'];&#10;&#10;// Get user profile&#10;$query = &quot;SELECT user_id, full_name, username, email, mobile_number, created_at &#10;          FROM users &#10;          WHERE user_id = :user_id&quot;;&#10;&#10;$stmt = $db-&gt;prepare($query);&#10;$stmt-&gt;bindParam(&quot;:user_id&quot;, $user_id);&#10;$stmt-&gt;execute();&#10;&#10;if ($stmt-&gt;rowCount() &gt; 0) {&#10;    $row = $stmt-&gt;fetch(PDO::FETCH_ASSOC);&#10;    &#10;    // Get user's post count&#10;    $post_query = &quot;SELECT COUNT(*) as post_count FROM posts WHERE user_id = :user_id AND status = 'active'&quot;;&#10;    $post_stmt = $db-&gt;prepare($post_query);&#10;    $post_stmt-&gt;bindParam(&quot;:user_id&quot;, $user_id);&#10;    $post_stmt-&gt;execute();&#10;    $post_data = $post_stmt-&gt;fetch(PDO::FETCH_ASSOC);&#10;    &#10;    http_response_code(200);&#10;    echo json_encode([&#10;        &quot;success&quot; =&gt; true,&#10;        &quot;data&quot; =&gt; [&#10;            &quot;user_id&quot; =&gt; $row['user_id'],&#10;            &quot;full_name&quot; =&gt; $row['full_name'],&#10;            &quot;username&quot; =&gt; $row['username'],&#10;            &quot;email&quot; =&gt; $row['email'],&#10;            &quot;mobile_number&quot; =&gt; $row['mobile_number'],&#10;            &quot;created_at&quot; =&gt; $row['created_at'],&#10;            &quot;post_count&quot; =&gt; $post_data['post_count']&#10;        ]&#10;    ]);&#10;} else {&#10;    http_response_code(404);&#10;    echo json_encode([&#10;        &quot;success&quot; =&gt; false,&#10;        &quot;message&quot; =&gt; &quot;User not found&quot;&#10;    ]);&#10;}&#10;?&gt;&#10;" />
              <option name="updatedContent" value="&lt;?php&#13;&#10;include_once '../config/cors.php';&#13;&#10;include_once '../config/database.php';&#13;&#10;&#13;&#10;$database = new Database();&#13;&#10;$db = $database-&gt;getConnection();&#13;&#10;&#13;&#10;// Check if user_id is provided as GET parameter&#13;&#10;if (isset($_GET['user_id'])) {&#13;&#10;    $user_id = $_GET['user_id'];&#13;&#10;} else {&#13;&#10;    // Fall back to token-based authentication&#13;&#10;    $headers = getallheaders();&#13;&#10;    $token = isset($headers['Authorization']) ? str_replace('Bearer ', '', $headers['Authorization']) : null;&#13;&#10;&#13;&#10;    if (!$token) {&#13;&#10;        http_response_code(401);&#13;&#10;        echo json_encode([&#13;&#10;            &quot;success&quot; =&gt; false,&#13;&#10;            &quot;message&quot; =&gt; &quot;User ID or authorization token required&quot;&#13;&#10;        ]);&#13;&#10;        exit();&#13;&#10;    }&#13;&#10;&#13;&#10;    // Verify token&#13;&#10;    $token_query = &quot;SELECT user_id FROM user_sessions WHERE token = :token AND expires_at &gt; NOW()&quot;;&#13;&#10;    $token_stmt = $db-&gt;prepare($token_query);&#13;&#10;    $token_stmt-&gt;bindParam(&quot;:token&quot;, $token);&#13;&#10;    $token_stmt-&gt;execute();&#13;&#10;&#13;&#10;    if ($token_stmt-&gt;rowCount() == 0) {&#13;&#10;        http_response_code(401);&#13;&#10;        echo json_encode([&#13;&#10;            &quot;success&quot; =&gt; false,&#13;&#10;            &quot;message&quot; =&gt; &quot;Invalid or expired token&quot;&#13;&#10;        ]);&#13;&#10;        exit();&#13;&#10;    }&#13;&#10;&#13;&#10;    $user_data = $token_stmt-&gt;fetch(PDO::FETCH_ASSOC);&#13;&#10;    $user_id = $user_data['user_id'];&#13;&#10;}&#13;&#10;&#13;&#10;// Get user profile&#13;&#10;$query = &quot;SELECT user_id, full_name, username, email, mobile_number, created_at &#13;&#10;          FROM users &#13;&#10;          WHERE user_id = :user_id&quot;;&#13;&#10;&#13;&#10;$stmt = $db-&gt;prepare($query);&#13;&#10;$stmt-&gt;bindParam(&quot;:user_id&quot;, $user_id);&#13;&#10;$stmt-&gt;execute();&#13;&#10;&#13;&#10;if ($stmt-&gt;rowCount() &gt; 0) {&#13;&#10;    $row = $stmt-&gt;fetch(PDO::FETCH_ASSOC);&#13;&#10;    &#13;&#10;    // Get user's post count&#13;&#10;    $post_query = &quot;SELECT COUNT(*) as post_count FROM posts WHERE user_id = :user_id AND status = 'active'&quot;;&#13;&#10;    $post_stmt = $db-&gt;prepare($post_query);&#13;&#10;    $post_stmt-&gt;bindParam(&quot;:user_id&quot;, $user_id);&#13;&#10;    $post_stmt-&gt;execute();&#13;&#10;    $post_data = $post_stmt-&gt;fetch(PDO::FETCH_ASSOC);&#13;&#10;    &#13;&#10;    http_response_code(200);&#13;&#10;    echo json_encode([&#13;&#10;        &quot;success&quot; =&gt; true,&#13;&#10;        &quot;data&quot; =&gt; [&#13;&#10;            &quot;user_id&quot; =&gt; $row['user_id'],&#13;&#10;            &quot;full_name&quot; =&gt; $row['full_name'],&#13;&#10;            &quot;username&quot; =&gt; $row['username'],&#13;&#10;            &quot;email&quot; =&gt; $row['email'],&#13;&#10;            &quot;mobile_number&quot; =&gt; $row['mobile_number'],&#13;&#10;            &quot;created_at&quot; =&gt; $row['created_at'],&#13;&#10;            &quot;post_count&quot; =&gt; $post_data['post_count']&#13;&#10;        ]&#13;&#10;    ]);&#13;&#10;} else {&#13;&#10;    http_response_code(404);&#13;&#10;    echo json_encode([&#13;&#10;        &quot;success&quot; =&gt; false,&#13;&#10;        &quot;message&quot; =&gt; &quot;User not found&quot;&#13;&#10;    ]);&#13;&#10;}&#13;&#10;?&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.google.gms.google.services)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.hamzatariq.lost_and_found_application&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.hamzatariq.lost_and_found_application&quot;&#10;        minSdk = 30&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.activity)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.firebase.auth)&#10;    &#10;    // Firebase Cloud Messaging for push notifications&#10;    implementation(platform(&quot;com.google.firebase:firebase-bom:32.7.0&quot;))&#10;    implementation(&quot;com.google.firebase:firebase-messaging-ktx&quot;)&#10;    implementation(&quot;com.google.firebase:firebase-analytics-ktx&quot;)&#10;&#10;    // Retrofit for API calls&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.gson)&#10;    implementation(libs.okhttp.logging)&#10;    &#10;    // Coroutines&#10;    implementation(libs.coroutines.android)&#10;    implementation(libs.coroutines.core)&#10;    &#10;    // Lifecycle&#10;    implementation(libs.lifecycle.viewmodel)&#10;    implementation(libs.lifecycle.livedata)&#10;    &#10;    // Room Database&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    implementation(libs.firebase.messaging)&#10;    implementation(libs.firebase.database)&#10;    implementation(libs.firebase.firestore)&#10;    implementation(libs.firebase.storage)&#10;    kapt(libs.room.compiler)&#10;    &#10;    // Glide for images&#10;    implementation(libs.glide)&#10;    &#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.google.gms.google.services)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.hamzatariq.lost_and_found_application&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.hamzatariq.lost_and_found_application&quot;&#10;        minSdk = 30&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.activity)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.firebase.auth)&#10;    &#10;    // Firebase Cloud Messaging for push notifications&#10;    implementation(platform(&quot;com.google.firebase:firebase-bom:32.7.0&quot;))&#10;    implementation(&quot;com.google.firebase:firebase-messaging-ktx&quot;)&#10;    implementation(&quot;com.google.firebase:firebase-analytics-ktx&quot;)&#10;&#10;    // Retrofit for API calls&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.gson)&#10;    implementation(libs.okhttp.logging)&#10;    &#10;    // Coroutines&#10;    implementation(libs.coroutines.android)&#10;    implementation(libs.coroutines.core)&#10;    &#10;    // Lifecycle&#10;    implementation(libs.lifecycle.viewmodel)&#10;    implementation(libs.lifecycle.livedata)&#10;    &#10;    // WorkManager for background tasks&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;)&#10;    &#10;    // Room Database&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    implementation(libs.firebase.messaging)&#10;    implementation(libs.firebase.database)&#10;    implementation(libs.firebase.firestore)&#10;    implementation(libs.firebase.storage)&#10;    kapt(libs.room.compiler)&#10;    &#10;    // Glide for images&#10;    implementation(libs.glide)&#10;    &#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/AddPostActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/AddPostActivity.kt" />
              <option name="originalContent" value="package com.hamzatariq.lost_and_found_application&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.provider.MediaStore&#10;import android.util.Base64&#10;import android.util.Log&#10;import android.widget.ImageView&#10;import android.widget.LinearLayout&#10;import android.widget.Toast&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.android.material.textfield.TextInputEditText&#10;import com.hamzatariq.lost_and_found_application.api.ApiConfig&#10;import com.hamzatariq.lost_and_found_application.viewmodel.PostViewModel&#10;import com.hamzatariq.lost_and_found_application.viewmodel.PostViewModelFactory&#10;import org.json.JSONObject&#10;import java.io.ByteArrayOutputStream&#10;import java.io.InputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;&#10;class AddPostActivity : AppCompatActivity() {&#10;&#10;    private var itemType = &quot;lost&quot; // Default to &quot;lost&quot;&#10;    private lateinit var lostItemButton: LinearLayout&#10;    private lateinit var foundItemButton: LinearLayout&#10;    private lateinit var itemNameInput: TextInputEditText&#10;    private lateinit var itemDescriptionInput: TextInputEditText&#10;    private lateinit var locationInput: TextInputEditText&#10;    private lateinit var uploadedImagePreview: ImageView&#10;    private lateinit var postButton: MaterialButton&#10;    private lateinit var postViewModel: PostViewModel&#10;    &#10;    private var selectedImageUri: Uri? = null&#10;    private var imageBase64: String? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AddPostActivity&quot;&#10;    }&#10;&#10;    // Image picker launcher&#10;    private val imagePickerLauncher = registerForActivityResult(&#10;        ActivityResultContracts.GetContent()&#10;    ) { uri: Uri? -&gt;&#10;        uri?.let {&#10;            selectedImageUri = it&#10;            uploadedImagePreview.setImageURI(it)&#10;            // Convert to base64&#10;            convertImageToBase64(it)&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            openImagePicker()&#10;        } else {&#10;            Toast.makeText(this, &quot;Permission denied to read storage&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_add_post)&#10;&#10;        // Hide the action bar for clean look&#10;        supportActionBar?.hide()&#10;&#10;        // Initialize ViewModel&#10;        postViewModel = ViewModelProvider(this, PostViewModelFactory(this))&#10;            .get(PostViewModel::class.java)&#10;&#10;        // Initialize views&#10;        lostItemButton = findViewById(R.id.lostItemButton)&#10;        foundItemButton = findViewById(R.id.foundItemButton)&#10;        itemNameInput = findViewById(R.id.itemNameInput)&#10;        itemDescriptionInput = findViewById(R.id.itemDescriptionInput)&#10;        locationInput = findViewById(R.id.locationInput)&#10;        uploadedImagePreview = findViewById(R.id.uploadedImagePreview)&#10;        postButton = findViewById(R.id.postButton)&#10;&#10;        // Observe post state&#10;        postViewModel.postState.observe(this) { state -&gt;&#10;            when (state) {&#10;                is PostViewModel.PostState.Loading -&gt; {&#10;                    postButton.isEnabled = false&#10;                    postButton.text = &quot;Creating Post...&quot;&#10;                }&#10;                is PostViewModel.PostState.Success -&gt; {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;                    Toast.makeText(this, state.message, Toast.LENGTH_SHORT).show()&#10;                    // Navigate back to home&#10;                    finish()&#10;                }&#10;                is PostViewModel.PostState.Error -&gt; {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;                    Toast.makeText(this, state.message, Toast.LENGTH_LONG).show()&#10;                }&#10;                PostViewModel.PostState.Idle -&gt; {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Handle back button click&#10;        val backButton = findViewById&lt;ImageView&gt;(R.id.backButton)&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;&#10;        // Handle Lost Item Button click&#10;        lostItemButton.setOnClickListener {&#10;            itemType = &quot;lost&quot;&#10;            updateItemTypeSelection()&#10;        }&#10;&#10;        // Handle Found Item Button click&#10;        foundItemButton.setOnClickListener {&#10;            itemType = &quot;found&quot;&#10;            updateItemTypeSelection()&#10;        }&#10;&#10;        // Handle image upload container click&#10;        val imageUploadContainer = findViewById&lt;android.widget.FrameLayout&gt;(R.id.imageUploadContainer)&#10;        imageUploadContainer.setOnClickListener {&#10;            checkPermissionAndPickImage()&#10;        }&#10;&#10;        // Handle Notify Me button click&#10;        val notifyMeButton = findViewById&lt;LinearLayout&gt;(R.id.notifyMeButton)&#10;        notifyMeButton.setOnClickListener {&#10;            Toast.makeText(this, &quot;Notification feature coming soon!&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;&#10;        // Handle post button click&#10;        postButton.setOnClickListener {&#10;            submitPost()&#10;        }&#10;&#10;        // Set default selection to Lost Item&#10;        updateItemTypeSelection()&#10;    }&#10;&#10;    private fun checkPermissionAndPickImage() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            // Android 13+ uses READ_MEDIA_IMAGES&#10;            if (ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    Manifest.permission.READ_MEDIA_IMAGES&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                openImagePicker()&#10;            } else {&#10;                permissionLauncher.launch(Manifest.permission.READ_MEDIA_IMAGES)&#10;            }&#10;        } else {&#10;            // Below Android 13&#10;            if (ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    Manifest.permission.READ_EXTERNAL_STORAGE&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                openImagePicker()&#10;            } else {&#10;                permissionLauncher.launch(Manifest.permission.READ_EXTERNAL_STORAGE)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun openImagePicker() {&#10;        imagePickerLauncher.launch(&quot;image/*&quot;)&#10;    }&#10;&#10;    private fun convertImageToBase64(uri: Uri) {&#10;        try {&#10;            val inputStream: InputStream? = contentResolver.openInputStream(uri)&#10;            val bitmap = BitmapFactory.decodeStream(inputStream)&#10;            inputStream?.close()&#10;            &#10;            // Compress and resize image&#10;            val resizedBitmap = resizeBitmap(bitmap, 1024, 1024)&#10;            val outputStream = ByteArrayOutputStream()&#10;            resizedBitmap.compress(Bitmap.CompressFormat.JPEG, 80, outputStream)&#10;            val imageBytes = outputStream.toByteArray()&#10;            &#10;            // Convert to base64&#10;            imageBase64 = &quot;data:image/jpeg;base64,&quot; + Base64.encodeToString(imageBytes, Base64.NO_WRAP)&#10;            &#10;            Toast.makeText(this, &quot;Image loaded successfully&quot;, Toast.LENGTH_SHORT).show()&#10;        } catch (e: Exception) {&#10;            Toast.makeText(this, &quot;Failed to load image: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun resizeBitmap(bitmap: Bitmap, maxWidth: Int, maxHeight: Int): Bitmap {&#10;        val width = bitmap.width&#10;        val height = bitmap.height&#10;        &#10;        if (width &lt;= maxWidth &amp;&amp; height &lt;= maxHeight) {&#10;            return bitmap&#10;        }&#10;        &#10;        val aspectRatio = width.toFloat() / height.toFloat()&#10;        val newWidth: Int&#10;        val newHeight: Int&#10;        &#10;        if (width &gt; height) {&#10;            newWidth = maxWidth&#10;            newHeight = (maxWidth / aspectRatio).toInt()&#10;        } else {&#10;            newHeight = maxHeight&#10;            newWidth = (maxHeight * aspectRatio).toInt()&#10;        }&#10;        &#10;        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)&#10;    }&#10;&#10;    private fun submitPost() {&#10;        val itemName = itemNameInput.text.toString().trim()&#10;        val itemDescription = itemDescriptionInput.text.toString().trim()&#10;        val location = locationInput.text.toString().trim()&#10;&#10;        // Validation&#10;        when {&#10;            itemName.isEmpty() -&gt; {&#10;                itemNameInput.error = &quot;Item name is required&quot;&#10;                itemNameInput.requestFocus()&#10;                return&#10;            }&#10;            itemDescription.isEmpty() -&gt; {&#10;                itemDescriptionInput.error = &quot;Item description is required&quot;&#10;                itemDescriptionInput.requestFocus()&#10;                return&#10;            }&#10;            location.isEmpty() -&gt; {&#10;                locationInput.error = &quot;Location is required&quot;&#10;                locationInput.requestFocus()&#10;                return&#10;            }&#10;        }&#10;&#10;        // If it's a lost item, create a lost item report&#10;        if (itemType == &quot;lost&quot;) {&#10;            createLostItemReport(itemName, itemDescription, location)&#10;        } else {&#10;            // Create found post via ViewModel&#10;            postViewModel.createPost(&#10;                itemName = itemName,&#10;                itemDescription = itemDescription,&#10;                location = location,&#10;                itemType = itemType,&#10;                imageBase64 = imageBase64&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun createLostItemReport(itemName: String, itemDescription: String, location: String) {&#10;        postButton.isEnabled = false&#10;        postButton.text = &quot;Creating Report...&quot;&#10;&#10;        Thread {&#10;            try {&#10;                val sharedPref = getSharedPreferences(&quot;lost_and_found_prefs&quot;, MODE_PRIVATE)&#10;                val userId = sharedPref.getInt(&quot;user_id&quot;, 0)&#10;&#10;                if (userId == 0) {&#10;                    runOnUiThread {&#10;                        postButton.isEnabled = true&#10;                        postButton.text = &quot;Post&quot;&#10;                        Toast.makeText(this, &quot;Please log in&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                    return@Thread&#10;                }&#10;&#10;                val url = URL(ApiConfig.getUrl(ApiConfig.Endpoints.CREATE_LOST_ITEM))&#10;                Log.d(TAG, &quot;Creating lost item report - URL: $url&quot;)&#10;&#10;                val connection = url.openConnection() as HttpURLConnection&#10;                connection.requestMethod = &quot;POST&quot;&#10;                connection.doOutput = true&#10;                connection.connectTimeout = 10000&#10;                connection.readTimeout = 10000&#10;&#10;                val postData = &quot;user_id=$userId&amp;item_name=$itemName&amp;item_description=$itemDescription&amp;location_lost=$location&quot;&#10;                connection.outputStream.write(postData.toByteArray())&#10;&#10;                val responseCode = connection.responseCode&#10;                Log.d(TAG, &quot;Lost item report response code: $responseCode&quot;)&#10;&#10;                val response = connection.inputStream.bufferedReader().readText()&#10;                Log.d(TAG, &quot;Lost item report response: $response&quot;)&#10;&#10;                val jsonResponse = JSONObject(response)&#10;&#10;                runOnUiThread {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;&#10;                    if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                        Toast.makeText(this, &quot;Lost item reported successfully! We'll notify you of matches.&quot;, Toast.LENGTH_LONG).show()&#10;                        finish()&#10;                    } else {&#10;                        val message = jsonResponse.getString(&quot;message&quot;)&#10;                        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Exception while creating lost item report: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;                    Toast.makeText(this, &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun updateItemTypeSelection() {&#10;        if (itemType == &quot;lost&quot;) {&#10;            // Lost item is selected - white background&#10;            lostItemButton.setBackgroundResource(R.drawable.item_type_button_selected_bg)&#10;            foundItemButton.setBackgroundResource(R.drawable.item_type_button_bg)&#10;        } else {&#10;            // Found item is selected - white background&#10;            foundItemButton.setBackgroundResource(R.drawable.item_type_button_selected_bg)&#10;            lostItemButton.setBackgroundResource(R.drawable.item_type_button_bg)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.provider.MediaStore&#10;import android.util.Base64&#10;import android.util.Log&#10;import android.widget.ImageView&#10;import android.widget.LinearLayout&#10;import android.widget.Toast&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.android.material.textfield.TextInputEditText&#10;import com.hamzatariq.lost_and_found_application.api.ApiConfig&#10;import com.hamzatariq.lost_and_found_application.firebase.DataSyncService&#10;import com.hamzatariq.lost_and_found_application.viewmodel.PostViewModel&#10;import com.hamzatariq.lost_and_found_application.viewmodel.PostViewModelFactory&#10;import org.json.JSONObject&#10;import java.io.ByteArrayOutputStream&#10;import java.io.InputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;&#10;class AddPostActivity : AppCompatActivity() {&#10;&#10;    private var itemType = &quot;lost&quot; // Default to &quot;lost&quot;&#10;    private lateinit var lostItemButton: LinearLayout&#10;    private lateinit var foundItemButton: LinearLayout&#10;    private lateinit var itemNameInput: TextInputEditText&#10;    private lateinit var itemDescriptionInput: TextInputEditText&#10;    private lateinit var locationInput: TextInputEditText&#10;    private lateinit var uploadedImagePreview: ImageView&#10;    private lateinit var postButton: MaterialButton&#10;    private lateinit var postViewModel: PostViewModel&#10;    &#10;    private var selectedImageUri: Uri? = null&#10;    private var imageBase64: String? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AddPostActivity&quot;&#10;    }&#10;&#10;    // Image picker launcher&#10;    private val imagePickerLauncher = registerForActivityResult(&#10;        ActivityResultContracts.GetContent()&#10;    ) { uri: Uri? -&gt;&#10;        uri?.let {&#10;            selectedImageUri = it&#10;            uploadedImagePreview.setImageURI(it)&#10;            // Convert to base64&#10;            convertImageToBase64(it)&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            openImagePicker()&#10;        } else {&#10;            Toast.makeText(this, &quot;Permission denied to read storage&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_add_post)&#10;&#10;        // Hide the action bar for clean look&#10;        supportActionBar?.hide()&#10;&#10;        // Initialize ViewModel&#10;        postViewModel = ViewModelProvider(this, PostViewModelFactory(this))&#10;            .get(PostViewModel::class.java)&#10;&#10;        // Initialize views&#10;        lostItemButton = findViewById(R.id.lostItemButton)&#10;        foundItemButton = findViewById(R.id.foundItemButton)&#10;        itemNameInput = findViewById(R.id.itemNameInput)&#10;        itemDescriptionInput = findViewById(R.id.itemDescriptionInput)&#10;        locationInput = findViewById(R.id.locationInput)&#10;        uploadedImagePreview = findViewById(R.id.uploadedImagePreview)&#10;        postButton = findViewById(R.id.postButton)&#10;&#10;        // Observe post state&#10;        postViewModel.postState.observe(this) { state -&gt;&#10;            when (state) {&#10;                is PostViewModel.PostState.Loading -&gt; {&#10;                    postButton.isEnabled = false&#10;                    postButton.text = &quot;Creating Post...&quot;&#10;                }&#10;                is PostViewModel.PostState.Success -&gt; {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;                    Toast.makeText(this, state.message, Toast.LENGTH_SHORT).show()&#10;                    // Navigate back to home&#10;                    finish()&#10;                }&#10;                is PostViewModel.PostState.Error -&gt; {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;                    Toast.makeText(this, state.message, Toast.LENGTH_LONG).show()&#10;                }&#10;                PostViewModel.PostState.Idle -&gt; {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Handle back button click&#10;        val backButton = findViewById&lt;ImageView&gt;(R.id.backButton)&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;&#10;        // Handle Lost Item Button click&#10;        lostItemButton.setOnClickListener {&#10;            itemType = &quot;lost&quot;&#10;            updateItemTypeSelection()&#10;        }&#10;&#10;        // Handle Found Item Button click&#10;        foundItemButton.setOnClickListener {&#10;            itemType = &quot;found&quot;&#10;            updateItemTypeSelection()&#10;        }&#10;&#10;        // Handle image upload container click&#10;        val imageUploadContainer = findViewById&lt;android.widget.FrameLayout&gt;(R.id.imageUploadContainer)&#10;        imageUploadContainer.setOnClickListener {&#10;            checkPermissionAndPickImage()&#10;        }&#10;&#10;        // Handle Notify Me button click&#10;        val notifyMeButton = findViewById&lt;LinearLayout&gt;(R.id.notifyMeButton)&#10;        notifyMeButton.setOnClickListener {&#10;            Toast.makeText(this, &quot;Notification feature coming soon!&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;&#10;        // Handle post button click&#10;        postButton.setOnClickListener {&#10;            submitPost()&#10;        }&#10;&#10;        // Set default selection to Lost Item&#10;        updateItemTypeSelection()&#10;    }&#10;&#10;    private fun checkPermissionAndPickImage() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            // Android 13+ uses READ_MEDIA_IMAGES&#10;            if (ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    Manifest.permission.READ_MEDIA_IMAGES&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                openImagePicker()&#10;            } else {&#10;                permissionLauncher.launch(Manifest.permission.READ_MEDIA_IMAGES)&#10;            }&#10;        } else {&#10;            // Below Android 13&#10;            if (ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    Manifest.permission.READ_EXTERNAL_STORAGE&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                openImagePicker()&#10;            } else {&#10;                permissionLauncher.launch(Manifest.permission.READ_EXTERNAL_STORAGE)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun openImagePicker() {&#10;        imagePickerLauncher.launch(&quot;image/*&quot;)&#10;    }&#10;&#10;    private fun convertImageToBase64(uri: Uri) {&#10;        try {&#10;            val inputStream: InputStream? = contentResolver.openInputStream(uri)&#10;            val bitmap = BitmapFactory.decodeStream(inputStream)&#10;            inputStream?.close()&#10;            &#10;            // Compress and resize image&#10;            val resizedBitmap = resizeBitmap(bitmap, 1024, 1024)&#10;            val outputStream = ByteArrayOutputStream()&#10;            resizedBitmap.compress(Bitmap.CompressFormat.JPEG, 80, outputStream)&#10;            val imageBytes = outputStream.toByteArray()&#10;            &#10;            // Convert to base64&#10;            imageBase64 = &quot;data:image/jpeg;base64,&quot; + Base64.encodeToString(imageBytes, Base64.NO_WRAP)&#10;            &#10;            Toast.makeText(this, &quot;Image loaded successfully&quot;, Toast.LENGTH_SHORT).show()&#10;        } catch (e: Exception) {&#10;            Toast.makeText(this, &quot;Failed to load image: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun resizeBitmap(bitmap: Bitmap, maxWidth: Int, maxHeight: Int): Bitmap {&#10;        val width = bitmap.width&#10;        val height = bitmap.height&#10;        &#10;        if (width &lt;= maxWidth &amp;&amp; height &lt;= maxHeight) {&#10;            return bitmap&#10;        }&#10;        &#10;        val aspectRatio = width.toFloat() / height.toFloat()&#10;        val newWidth: Int&#10;        val newHeight: Int&#10;        &#10;        if (width &gt; height) {&#10;            newWidth = maxWidth&#10;            newHeight = (maxWidth / aspectRatio).toInt()&#10;        } else {&#10;            newHeight = maxHeight&#10;            newWidth = (maxHeight * aspectRatio).toInt()&#10;        }&#10;        &#10;        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)&#10;    }&#10;&#10;    private fun submitPost() {&#10;        val itemName = itemNameInput.text.toString().trim()&#10;        val itemDescription = itemDescriptionInput.text.toString().trim()&#10;        val location = locationInput.text.toString().trim()&#10;&#10;        // Validation&#10;        when {&#10;            itemName.isEmpty() -&gt; {&#10;                itemNameInput.error = &quot;Item name is required&quot;&#10;                itemNameInput.requestFocus()&#10;                return&#10;            }&#10;            itemDescription.isEmpty() -&gt; {&#10;                itemDescriptionInput.error = &quot;Item description is required&quot;&#10;                itemDescriptionInput.requestFocus()&#10;                return&#10;            }&#10;            location.isEmpty() -&gt; {&#10;                locationInput.error = &quot;Location is required&quot;&#10;                locationInput.requestFocus()&#10;                return&#10;            }&#10;        }&#10;&#10;        // If it's a lost item, create a lost item report&#10;        if (itemType == &quot;lost&quot;) {&#10;            createLostItemReport(itemName, itemDescription, location)&#10;        } else {&#10;            // Create found post via ViewModel&#10;            postViewModel.createPost(&#10;                itemName = itemName,&#10;                itemDescription = itemDescription,&#10;                location = location,&#10;                itemType = itemType,&#10;                imageBase64 = imageBase64&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun createLostItemReport(itemName: String, itemDescription: String, location: String) {&#10;        postButton.isEnabled = false&#10;        postButton.text = &quot;Creating Report...&quot;&#10;&#10;        Thread {&#10;            try {&#10;                val sharedPref = getSharedPreferences(&quot;lost_and_found_prefs&quot;, MODE_PRIVATE)&#10;                val userId = sharedPref.getInt(&quot;user_id&quot;, 0)&#10;&#10;                if (userId == 0) {&#10;                    runOnUiThread {&#10;                        postButton.isEnabled = true&#10;                        postButton.text = &quot;Post&quot;&#10;                        Toast.makeText(this, &quot;Please log in&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                    return@Thread&#10;                }&#10;&#10;                val url = URL(ApiConfig.getUrl(ApiConfig.Endpoints.CREATE_LOST_ITEM))&#10;                Log.d(TAG, &quot;Creating lost item report - URL: $url&quot;)&#10;&#10;                val connection = url.openConnection() as HttpURLConnection&#10;                connection.requestMethod = &quot;POST&quot;&#10;                connection.doOutput = true&#10;                connection.connectTimeout = 10000&#10;                connection.readTimeout = 10000&#10;&#10;                val postData = &quot;user_id=$userId&amp;item_name=$itemName&amp;item_description=$itemDescription&amp;location_lost=$location&quot;&#10;                connection.outputStream.write(postData.toByteArray())&#10;&#10;                val responseCode = connection.responseCode&#10;                Log.d(TAG, &quot;Lost item report response code: $responseCode&quot;)&#10;&#10;                val response = connection.inputStream.bufferedReader().readText()&#10;                Log.d(TAG, &quot;Lost item report response: $response&quot;)&#10;&#10;                val jsonResponse = JSONObject(response)&#10;&#10;                runOnUiThread {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;&#10;                    if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                        // Sync to Firebase after successful creation&#10;                        val dataSyncService = DataSyncService(this)&#10;                        dataSyncService.syncPostsToFirebase(userId)&#10;                        Log.d(TAG, &quot;Lost item synced to Firebase&quot;)&#10;                        &#10;                        Toast.makeText(this, &quot;Lost item reported successfully! We'll notify you of matches.&quot;, Toast.LENGTH_LONG).show()&#10;                        finish()&#10;                    } else {&#10;                        val message = jsonResponse.getString(&quot;message&quot;)&#10;                        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Exception while creating lost item report: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    postButton.isEnabled = true&#10;                    postButton.text = &quot;Post&quot;&#10;                    Toast.makeText(this, &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun updateItemTypeSelection() {&#10;        if (itemType == &quot;lost&quot;) {&#10;            // Lost item is selected - white background&#10;            lostItemButton.setBackgroundResource(R.drawable.item_type_button_selected_bg)&#10;            foundItemButton.setBackgroundResource(R.drawable.item_type_button_bg)&#10;        } else {&#10;            // Found item is selected - white background&#10;            foundItemButton.setBackgroundResource(R.drawable.item_type_button_selected_bg)&#10;            lostItemButton.setBackgroundResource(R.drawable.item_type_button_bg)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/api/ApiConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/api/ApiConfig.kt" />
              <option name="originalContent" value="package com.hamzatariq.lost_and_found_application.api&#10;&#10;import android.content.Context&#10;import android.net.wifi.WifiManager&#10;import android.os.Build&#10;import java.net.NetworkInterface&#10;&#10;object ApiConfig {&#10;&#10;    // Configuration options - Change this to switch environments&#10;    enum class Environment {&#10;        EMULATOR,           // Use 10.0.2.2 for Android Emulator&#10;        PHYSICAL_DEVICE,    // Use your local network IP&#10;        CUSTOM              // Use a custom IP&#10;    }&#10;&#10;    // **CHANGE THIS TO MATCH YOUR SETUP**&#10;    private var currentEnvironment = Environment.EMULATOR&#10;&#10;    // For physical devices, set your computer's local IP address here&#10;    // Find it by running 'ipconfig' (Windows) or 'ifconfig' (Mac/Linux)&#10;    private const val LOCAL_NETWORK_IP = &quot;192.168.18.17&quot; // Your PC's actual IP address&#10;&#10;    // For custom setup&#10;    private const val CUSTOM_IP = &quot;192.168.18.17&quot;&#10;&#10;    // API paths&#10;    private const val API_PATH = &quot;/lost_and_found_api/&quot;&#10;&#10;    /**&#10;     * Get the base URL based on current environment&#10;     */&#10;    fun getBaseUrl(): String {&#10;        // Auto-detect on every call to ensure it's always correct&#10;        autoDetectEnvironment()&#10;&#10;        val baseUrl = when (currentEnvironment) {&#10;            Environment.EMULATOR -&gt; &quot;http://10.0.2.2$API_PATH&quot;&#10;            Environment.PHYSICAL_DEVICE -&gt; &quot;http://$LOCAL_NETWORK_IP$API_PATH&quot;&#10;            Environment.CUSTOM -&gt; &quot;http://$CUSTOM_IP$API_PATH&quot;&#10;        }&#10;&#10;        android.util.Log.d(&quot;ApiConfig&quot;, &quot;Environment: $currentEnvironment, Base URL: $baseUrl&quot;)&#10;        return baseUrl&#10;    }&#10;&#10;    /**&#10;     * Auto-detect environment (emulator vs physical device)&#10;     * Call this early in your app to set the right environment&#10;     */&#10;    fun autoDetectEnvironment() {&#10;        currentEnvironment = if (isEmulator()) {&#10;            Environment.EMULATOR&#10;        } else {&#10;            Environment.PHYSICAL_DEVICE&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Manually set the environment&#10;     */&#10;    fun setEnvironment(environment: Environment) {&#10;        currentEnvironment = environment&#10;    }&#10;&#10;    /**&#10;     * Set custom IP address&#10;     */&#10;    fun setCustomIP(ip: String) {&#10;        currentEnvironment = Environment.CUSTOM&#10;        // You can store this in SharedPreferences for persistence&#10;    }&#10;&#10;    /**&#10;     * Get current environment&#10;     */&#10;    fun getCurrentEnvironment(): Environment = currentEnvironment&#10;&#10;    /**&#10;     * Check if running on emulator&#10;     */&#10;    private fun isEmulator(): Boolean {&#10;        return (Build.FINGERPRINT.startsWith(&quot;google/sdk_gphone_&quot;)&#10;                || Build.FINGERPRINT.startsWith(&quot;generic&quot;)&#10;                || Build.FINGERPRINT.contains(&quot;vbox&quot;)&#10;                || Build.FINGERPRINT.contains(&quot;emulator&quot;)&#10;                || Build.MODEL.contains(&quot;google_sdk&quot;)&#10;                || Build.MODEL.contains(&quot;Emulator&quot;)&#10;                || Build.MODEL.contains(&quot;Android SDK built for x86&quot;)&#10;                || Build.MANUFACTURER.contains(&quot;Genymotion&quot;)&#10;                || Build.BRAND.startsWith(&quot;generic&quot;) &amp;&amp; Build.DEVICE.startsWith(&quot;generic&quot;)&#10;                || &quot;google_sdk&quot; == Build.PRODUCT)&#10;    }&#10;&#10;    /**&#10;     * Get the device's local IP address (useful for debugging)&#10;     */&#10;    fun getDeviceIP(): String? {&#10;        try {&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#10;            while (interfaces.hasMoreElements()) {&#10;                val networkInterface = interfaces.nextElement()&#10;                val addresses = networkInterface.inetAddresses&#10;                while (addresses.hasMoreElements()) {&#10;                    val address = addresses.nextElement()&#10;                    if (!address.isLoopbackAddress &amp;&amp; address.address.size == 4) {&#10;                        return address.hostAddress&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;        return null&#10;    }&#10;&#10;    // Full URL builders for convenience&#10;    fun getUrl(endpoint: String): String = &quot;${getBaseUrl()}$endpoint&quot;&#10;&#10;    // Specific endpoints&#10;    object Endpoints {&#10;        const val UPDATE_FCM_TOKEN = &quot;user/update_fcm_token.php&quot;&#10;        const val GET_PROFILE = &quot;user/get_profile.php&quot;&#10;        const val UPDATE_PROFILE = &quot;user/update_profile.php&quot;&#10;        const val GET_MY_LOST_ITEMS = &quot;posts/get_my_lost_items.php&quot;&#10;        const val GET_MATCHING_POSTS = &quot;posts/get_matching_posts.php&quot;&#10;        const val GET_MY_POSTS = &quot;posts/get_my_posts.php&quot;&#10;        const val UPDATE_STATUS = &quot;posts/update_status.php&quot;&#10;        const val CHAT_API = &quot;chat/chat_api.php&quot;&#10;        const val CREATE_LOST_ITEM = &quot;posts/create_lost_item.php&quot;&#10;        const val GET_MESSAGES = &quot;chat/chat_api.php&quot;&#10;        const val SEND_MESSAGE = &quot;chat/chat_api.php&quot;&#10;        const val MARK_READ = &quot;chat/chat_api.php&quot;&#10;        const val GET_ROOMS = &quot;chat/chat_api.php&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application.api&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.net.wifi.WifiManager&#13;&#10;import android.os.Build&#13;&#10;import java.net.NetworkInterface&#13;&#10;&#13;&#10;object ApiConfig {&#13;&#10;&#13;&#10;    // Configuration options - Change this to switch environments&#13;&#10;    enum class Environment {&#13;&#10;        EMULATOR,           // Use 10.0.2.2 for Android Emulator&#13;&#10;        PHYSICAL_DEVICE,    // Use your local network IP&#13;&#10;        CUSTOM              // Use a custom IP&#13;&#10;    }&#13;&#10;&#13;&#10;    // **CHANGE THIS TO MATCH YOUR SETUP**&#13;&#10;    private var currentEnvironment = Environment.EMULATOR&#13;&#10;&#13;&#10;    // For physical devices, set your computer's local IP address here&#13;&#10;    // Find it by running 'ipconfig' (Windows) or 'ifconfig' (Mac/Linux)&#13;&#10;    private const val LOCAL_NETWORK_IP = &quot;192.168.18.17&quot; // Your PC's actual IP address&#13;&#10;&#13;&#10;    // For custom setup&#13;&#10;    private const val CUSTOM_IP = &quot;192.168.18.17&quot;&#13;&#10;&#13;&#10;    // API paths&#13;&#10;    private const val API_PATH = &quot;/lost_and_found_api/&quot;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the base URL based on current environment&#13;&#10;     */&#13;&#10;    fun getBaseUrl(): String {&#13;&#10;        // Auto-detect on every call to ensure it's always correct&#13;&#10;        autoDetectEnvironment()&#13;&#10;&#13;&#10;        val baseUrl = when (currentEnvironment) {&#13;&#10;            Environment.EMULATOR -&gt; &quot;http://10.0.2.2$API_PATH&quot;&#13;&#10;            Environment.PHYSICAL_DEVICE -&gt; &quot;http://$LOCAL_NETWORK_IP$API_PATH&quot;&#13;&#10;            Environment.CUSTOM -&gt; &quot;http://$CUSTOM_IP$API_PATH&quot;&#13;&#10;        }&#13;&#10;&#13;&#10;        android.util.Log.d(&quot;ApiConfig&quot;, &quot;Environment: $currentEnvironment, Base URL: $baseUrl&quot;)&#13;&#10;        return baseUrl&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Auto-detect environment (emulator vs physical device)&#13;&#10;     * Call this early in your app to set the right environment&#13;&#10;     */&#13;&#10;    fun autoDetectEnvironment() {&#13;&#10;        currentEnvironment = if (isEmulator()) {&#13;&#10;            Environment.EMULATOR&#13;&#10;        } else {&#13;&#10;            Environment.PHYSICAL_DEVICE&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Manually set the environment&#13;&#10;     */&#13;&#10;    fun setEnvironment(environment: Environment) {&#13;&#10;        currentEnvironment = environment&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Set custom IP address&#13;&#10;     */&#13;&#10;    fun setCustomIP(ip: String) {&#13;&#10;        currentEnvironment = Environment.CUSTOM&#13;&#10;        // You can store this in SharedPreferences for persistence&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get current environment&#13;&#10;     */&#13;&#10;    fun getCurrentEnvironment(): Environment = currentEnvironment&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if running on emulator&#13;&#10;     */&#13;&#10;    private fun isEmulator(): Boolean {&#13;&#10;        return (Build.FINGERPRINT.startsWith(&quot;google/sdk_gphone_&quot;)&#13;&#10;                || Build.FINGERPRINT.startsWith(&quot;generic&quot;)&#13;&#10;                || Build.FINGERPRINT.contains(&quot;vbox&quot;)&#13;&#10;                || Build.FINGERPRINT.contains(&quot;emulator&quot;)&#13;&#10;                || Build.MODEL.contains(&quot;google_sdk&quot;)&#13;&#10;                || Build.MODEL.contains(&quot;Emulator&quot;)&#13;&#10;                || Build.MODEL.contains(&quot;Android SDK built for x86&quot;)&#13;&#10;                || Build.MANUFACTURER.contains(&quot;Genymotion&quot;)&#13;&#10;                || Build.BRAND.startsWith(&quot;generic&quot;) &amp;&amp; Build.DEVICE.startsWith(&quot;generic&quot;)&#13;&#10;                || &quot;google_sdk&quot; == Build.PRODUCT)&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the device's local IP address (useful for debugging)&#13;&#10;     */&#13;&#10;    fun getDeviceIP(): String? {&#13;&#10;        try {&#13;&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#13;&#10;            while (interfaces.hasMoreElements()) {&#13;&#10;                val networkInterface = interfaces.nextElement()&#13;&#10;                val addresses = networkInterface.inetAddresses&#13;&#10;                while (addresses.hasMoreElements()) {&#13;&#10;                    val address = addresses.nextElement()&#13;&#10;                    if (!address.isLoopbackAddress &amp;&amp; address.address.size == 4) {&#13;&#10;                        return address.hostAddress&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            e.printStackTrace()&#13;&#10;        }&#13;&#10;        return null&#13;&#10;    }&#13;&#10;&#13;&#10;    // Full URL builders for convenience&#13;&#10;    fun getUrl(endpoint: String): String = &quot;${getBaseUrl()}$endpoint&quot;&#13;&#10;&#13;&#10;    // Specific endpoints&#13;&#10;    object Endpoints {&#13;&#10;        const val UPDATE_FCM_TOKEN = &quot;user/update_fcm_token.php&quot;&#13;&#10;        const val GET_PROFILE = &quot;user/get_profile.php&quot;&#13;&#10;        const val UPDATE_PROFILE = &quot;user/update_profile.php&quot;&#13;&#10;        const val GET_MY_LOST_ITEMS = &quot;posts/get_my_lost_items.php&quot;&#13;&#10;        const val GET_MATCHING_POSTS = &quot;posts/get_matching_posts.php&quot;&#13;&#10;        const val GET_MY_POSTS = &quot;posts/get_my_posts.php&quot;&#13;&#10;        const val UPDATE_STATUS = &quot;posts/update_status.php&quot;&#13;&#10;        const val CHAT_API = &quot;chat/chat_api.php&quot;&#13;&#10;        const val CREATE_LOST_ITEM = &quot;posts/create_lost_item.php&quot;&#13;&#10;        const val GET_MESSAGES = &quot;chat/chat_api.php&quot;&#13;&#10;        const val SEND_MESSAGE = &quot;chat/chat_api.php&quot;&#13;&#10;        const val MARK_READ = &quot;chat/chat_api.php&quot;&#13;&#10;        const val GET_ROOMS = &quot;chat/chat_api.php&quot;&#13;&#10;        const val GET_LOST_ITEMS = &quot;posts/get_lost_items.php&quot;&#13;&#10;        const val GET_NOTIFICATIONS = &quot;notifications/get_notifications.php&quot;&#13;&#10;        const val BASE_URL = &quot;&quot;  // This will be handled by getBaseUrl()&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/firebase/DataSyncService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/firebase/DataSyncService.kt" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application.firebase&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.google.firebase.Timestamp&#10;import com.hamzatariq.lost_and_found_application.api.ApiConfig&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;&#10;/**&#10; * Synchronizes data between MySQL (primary) and Firebase Firestore (real-time)&#10; */&#10;class DataSyncService(private val context: Context) {&#10;&#10;    private val firestoreHelper = FirestoreHelper()&#10;    private val prefsManager = SharedPreferencesManager(context)&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;DataSyncService&quot;&#10;    }&#10;&#10;    /**&#10;     * Sync user data from MySQL to Firebase&#10;     */&#10;    fun syncUserToFirebase(userId: Int) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val url = URL(ApiConfig.getUrl(ApiConfig.Endpoints.GET_PROFILE) + &quot;?user_id=$userId&quot;)&#10;                val connection = url.openConnection() as HttpURLConnection&#10;                connection.requestMethod = &quot;GET&quot;&#10;                connection.connectTimeout = 10000&#10;                &#10;                val response = connection.inputStream.bufferedReader().readText()&#10;                val jsonResponse = JSONObject(response)&#10;                &#10;                if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                    val userData = jsonResponse.getJSONObject(&quot;data&quot;)&#10;                    &#10;                    val firebaseUserData = mapOf(&#10;                        &quot;user_id&quot; to userData.getInt(&quot;user_id&quot;),&#10;                        &quot;full_name&quot; to userData.getString(&quot;full_name&quot;),&#10;                        &quot;username&quot; to userData.getString(&quot;username&quot;),&#10;                        &quot;email&quot; to userData.getString(&quot;email&quot;),&#10;                        &quot;mobile_number&quot; to userData.optString(&quot;mobile_number&quot;, &quot;&quot;),&#10;                        &quot;fcm_token&quot; to (prefsManager.getFCMToken() ?: &quot;&quot;),&#10;                        &quot;is_active&quot; to true,&#10;                        &quot;created_at&quot; to Timestamp.now(),&#10;                        &quot;updated_at&quot; to Timestamp.now(),&#10;                        &quot;post_count&quot; to userData.optInt(&quot;post_count&quot;, 0)&#10;                    )&#10;                    &#10;                    val success = firestoreHelper.createUser(firebaseUserData)&#10;                    if (success) {&#10;                        Log.d(TAG, &quot;User synced to Firebase: $userId&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error syncing user to Firebase: ${e.message}&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sync all posts from MySQL to Firebase&#10;     */&#10;    fun syncPostsToFirebase(userId: Int? = null) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val endpoint = if (userId != null) {&#10;                    ApiConfig.getUrl(ApiConfig.Endpoints.GET_LOST_ITEMS) + &quot;?user_id=$userId&quot;&#10;                } else {&#10;                    ApiConfig.getUrl(ApiConfig.Endpoints.GET_LOST_ITEMS)&#10;                }&#10;                &#10;                val url = URL(endpoint)&#10;                val connection = url.openConnection() as HttpURLConnection&#10;                connection.requestMethod = &quot;GET&quot;&#10;                connection.connectTimeout = 10000&#10;                &#10;                val response = connection.inputStream.bufferedReader().readText()&#10;                val jsonResponse = JSONObject(response)&#10;                &#10;                if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                    val postsArray = jsonResponse.getJSONArray(&quot;data&quot;)&#10;                    &#10;                    for (i in 0 until postsArray.length()) {&#10;                        val post = postsArray.getJSONObject(i)&#10;                        &#10;                        val firebasePostData = mapOf(&#10;                            &quot;post_id&quot; to post.getInt(&quot;post_id&quot;),&#10;                            &quot;user_id&quot; to post.getInt(&quot;user_id&quot;).toString(),&#10;                            &quot;item_name&quot; to post.getString(&quot;item_name&quot;),&#10;                            &quot;item_description&quot; to post.getString(&quot;item_description&quot;),&#10;                            &quot;location&quot; to post.getString(&quot;location&quot;),&#10;                            &quot;item_type&quot; to post.getString(&quot;item_type&quot;),&#10;                            &quot;item_image&quot; to post.optString(&quot;item_image&quot;, &quot;&quot;),&#10;                            &quot;status&quot; to post.optString(&quot;status&quot;, &quot;active&quot;),&#10;                            &quot;created_at&quot; to Timestamp.now(),&#10;                            &quot;updated_at&quot; to Timestamp.now(),&#10;                            &quot;sync_status&quot; to true&#10;                        )&#10;                        &#10;                        firestoreHelper.createPost(firebasePostData)&#10;                    }&#10;                    &#10;                    Log.d(TAG, &quot;Posts synced to Firebase: ${postsArray.length()}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error syncing posts to Firebase: ${e.message}&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sync notifications from MySQL to Firebase&#10;     */&#10;    fun syncNotificationsToFirebase(userId: Int) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val url = URL(ApiConfig.getUrl(ApiConfig.Endpoints.GET_NOTIFICATIONS) + &quot;?user_id=$userId&quot;)&#10;                val connection = url.openConnection() as HttpURLConnection&#10;                connection.requestMethod = &quot;GET&quot;&#10;                connection.connectTimeout = 10000&#10;                &#10;                val response = connection.inputStream.bufferedReader().readText()&#10;                val jsonResponse = JSONObject(response)&#10;                &#10;                if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                    val notificationsArray = jsonResponse.getJSONArray(&quot;data&quot;)&#10;                    &#10;                    for (i in 0 until notificationsArray.length()) {&#10;                        val notification = notificationsArray.getJSONObject(i)&#10;                        &#10;                        val firebaseNotifData = mapOf(&#10;                            &quot;notification_id&quot; to notification.getInt(&quot;notification_id&quot;),&#10;                            &quot;user_id&quot; to userId.toString(),&#10;                            &quot;post_id&quot; to notification.getInt(&quot;post_id&quot;),&#10;                            &quot;notification_type&quot; to notification.optString(&quot;notification_type&quot;, &quot;match&quot;),&#10;                            &quot;title&quot; to notification.getString(&quot;title&quot;),&#10;                            &quot;message&quot; to notification.getString(&quot;message&quot;),&#10;                            &quot;is_read&quot; to notification.optBoolean(&quot;is_read&quot;, false),&#10;                            &quot;created_at&quot; to Timestamp.now()&#10;                        )&#10;                        &#10;                        firestoreHelper.createNotification(firebaseNotifData)&#10;                    }&#10;                    &#10;                    Log.d(TAG, &quot;Notifications synced to Firebase: ${notificationsArray.length()}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error syncing notifications to Firebase: ${e.message}&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create post in both MySQL and Firebase&#10;     */&#10;    suspend fun createPostDualSync(postData: JSONObject): Boolean {&#10;        return try {&#10;            // First create in MySQL&#10;            val url = URL(ApiConfig.getUrl(ApiConfig.Endpoints.CREATE_LOST_ITEM))&#10;            val connection = url.openConnection() as HttpURLConnection&#10;            connection.requestMethod = &quot;POST&quot;&#10;            connection.doOutput = true&#10;            connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            &#10;            connection.outputStream.write(postData.toString().toByteArray())&#10;            &#10;            val response = connection.inputStream.bufferedReader().readText()&#10;            val jsonResponse = JSONObject(response)&#10;            &#10;            if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                val postId = jsonResponse.optInt(&quot;post_id&quot;, -1)&#10;                &#10;                // Then sync to Firebase&#10;                val firebasePostData = mapOf(&#10;                    &quot;post_id&quot; to postId,&#10;                    &quot;user_id&quot; to postData.getInt(&quot;user_id&quot;).toString(),&#10;                    &quot;item_name&quot; to postData.getString(&quot;item_name&quot;),&#10;                    &quot;item_description&quot; to postData.getString(&quot;item_description&quot;),&#10;                    &quot;location&quot; to postData.getString(&quot;location&quot;),&#10;                    &quot;item_type&quot; to postData.getString(&quot;item_type&quot;),&#10;                    &quot;item_image&quot; to postData.optString(&quot;item_image&quot;, &quot;&quot;),&#10;                    &quot;status&quot; to &quot;active&quot;,&#10;                    &quot;created_at&quot; to Timestamp.now(),&#10;                    &quot;updated_at&quot; to Timestamp.now(),&#10;                    &quot;sync_status&quot; to true&#10;                )&#10;                &#10;                firestoreHelper.createPost(firebasePostData)&#10;                Log.d(TAG, &quot;Post created in both MySQL and Firebase&quot;)&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error creating post dual sync: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update FCM token in both MySQL and Firebase&#10;     */&#10;    fun updateFCMTokenDualSync(userId: Int, fcmToken: String) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                // Update in MySQL&#10;                val url = URL(ApiConfig.getUrl(ApiConfig.Endpoints.UPDATE_FCM_TOKEN))&#10;                val connection = url.openConnection() as HttpURLConnection&#10;                connection.requestMethod = &quot;POST&quot;&#10;                connection.doOutput = true&#10;                connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                &#10;                val jsonPayload = JSONObject().apply {&#10;                    put(&quot;user_id&quot;, userId)&#10;                    put(&quot;fcm_token&quot;, fcmToken)&#10;                }&#10;                &#10;                connection.outputStream.write(jsonPayload.toString().toByteArray())&#10;                &#10;                val response = connection.inputStream.bufferedReader().readText()&#10;                val jsonResponse = JSONObject(response)&#10;                &#10;                if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                    // Update in Firebase&#10;                    firestoreHelper.updateFCMToken(userId.toString(), fcmToken)&#10;                    Log.d(TAG, &quot;FCM token updated in both MySQL and Firebase&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error updating FCM token: ${e.message}&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Perform full sync of user data&#10;     */&#10;    fun performFullSync(userId: Int) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            Log.d(TAG, &quot;Starting full sync for user: $userId&quot;)&#10;            &#10;            // Sync user profile&#10;            syncUserToFirebase(userId)&#10;            &#10;            // Wait a bit&#10;            kotlinx.coroutines.delay(1000)&#10;            &#10;            // Sync user's posts&#10;            syncPostsToFirebase(userId)&#10;            &#10;            // Wait a bit&#10;            kotlinx.coroutines.delay(1000)&#10;            &#10;            // Sync notifications&#10;            syncNotificationsToFirebase(userId)&#10;            &#10;            Log.d(TAG, &quot;Full sync completed for user: $userId&quot;)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/firebase/FirebaseMigrationWorker.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/firebase/FirebaseMigrationWorker.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application.firebase&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.work.*&#10;import com.google.firebase.Timestamp&#10;import com.hamzatariq.lost_and_found_application.api.ApiConfig&#10;import org.json.JSONObject&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Background worker to migrate all MySQL data to Firebase&#10; * Run this once to perform initial data migration&#10; */&#10;class FirebaseMigrationWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    private val firestoreHelper = FirestoreHelper()&#10;&#10;    companion object {&#10;        private const val TAG = &quot;FirebaseMigration&quot;&#10;        const val WORK_NAME = &quot;firebase_migration_work&quot;&#10;&#10;        fun scheduleInitialMigration(context: Context) {&#10;            val workRequest = OneTimeWorkRequestBuilder&lt;FirebaseMigrationWorker&gt;()&#10;                .setConstraints(&#10;                    Constraints.Builder()&#10;                        .setRequiredNetworkType(NetworkType.CONNECTED)&#10;                        .build()&#10;                )&#10;                .setBackoffCriteria(&#10;                    BackoffPolicy.LINEAR,&#10;                    WorkRequest.MIN_BACKOFF_MILLIS,&#10;                    TimeUnit.MILLISECONDS&#10;                )&#10;                .build()&#10;&#10;            WorkManager.getInstance(context)&#10;                .enqueueUniqueWork(&#10;                    WORK_NAME,&#10;                    ExistingWorkPolicy.REPLACE,&#10;                    workRequest&#10;                )&#10;        }&#10;    }&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            Log.d(TAG, &quot;Starting Firebase migration...&quot;)&#10;&#10;            setProgress(workDataOf(&quot;status&quot; to &quot;Migrating users...&quot;))&#10;            migrateAllUsers()&#10;&#10;            setProgress(workDataOf(&quot;status&quot; to &quot;Migrating posts...&quot;))&#10;            migrateAllPosts()&#10;&#10;            setProgress(workDataOf(&quot;status&quot; to &quot;Migration complete!&quot;))&#10;            Log.d(TAG, &quot;Firebase migration completed successfully&quot;)&#10;&#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Migration failed: ${e.message}&quot;, e)&#10;            Result.retry()&#10;        }&#10;    }&#10;&#10;    private suspend fun migrateAllUsers() {&#10;        try {&#10;            val url = URL(&quot;${ApiConfig.getBaseUrl()}user/get_all_users.php&quot;)&#10;            val connection = url.openConnection() as HttpURLConnection&#10;            connection.requestMethod = &quot;GET&quot;&#10;            connection.connectTimeout = 30000&#10;            connection.readTimeout = 30000&#10;&#10;            val response = connection.inputStream.bufferedReader().readText()&#10;            val jsonResponse = JSONObject(response)&#10;&#10;            if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                val usersArray = jsonResponse.getJSONArray(&quot;data&quot;)&#10;&#10;                for (i in 0 until usersArray.length()) {&#10;                    val user = usersArray.getJSONObject(i)&#10;&#10;                    val firebaseUserData = mapOf(&#10;                        &quot;user_id&quot; to user.getInt(&quot;user_id&quot;),&#10;                        &quot;full_name&quot; to user.getString(&quot;full_name&quot;),&#10;                        &quot;username&quot; to user.getString(&quot;username&quot;),&#10;                        &quot;email&quot; to user.getString(&quot;email&quot;),&#10;                        &quot;mobile_number&quot; to user.optString(&quot;mobile_number&quot;, &quot;&quot;),&#10;                        &quot;fcm_token&quot; to user.optString(&quot;fcm_token&quot;, &quot;&quot;),&#10;                        &quot;is_active&quot; to user.optBoolean(&quot;is_active&quot;, true),&#10;                        &quot;created_at&quot; to Timestamp.now(),&#10;                        &quot;updated_at&quot; to Timestamp.now()&#10;                    )&#10;&#10;                    firestoreHelper.createUser(firebaseUserData)&#10;                    Log.d(TAG, &quot;Migrated user: ${user.getString(&quot;username&quot;)}&quot;)&#10;                }&#10;&#10;                Log.d(TAG, &quot;Total users migrated: ${usersArray.length()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error migrating users: ${e.message}&quot;, e)&#10;            // Continue with migration even if this fails&#10;        }&#10;    }&#10;&#10;    private suspend fun migrateAllPosts() {&#10;        try {&#10;            val url = URL(ApiConfig.getUrl(ApiConfig.Endpoints.GET_LOST_ITEMS))&#10;            val connection = url.openConnection() as HttpURLConnection&#10;            connection.requestMethod = &quot;GET&quot;&#10;            connection.connectTimeout = 30000&#10;            connection.readTimeout = 30000&#10;&#10;            val response = connection.inputStream.bufferedReader().readText()&#10;            val jsonResponse = JSONObject(response)&#10;&#10;            if (jsonResponse.getBoolean(&quot;success&quot;)) {&#10;                val postsArray = jsonResponse.getJSONArray(&quot;data&quot;)&#10;&#10;                for (i in 0 until postsArray.length()) {&#10;                    val post = postsArray.getJSONObject(i)&#10;&#10;                    val firebasePostData = mapOf(&#10;                        &quot;post_id&quot; to post.getInt(&quot;post_id&quot;),&#10;                        &quot;user_id&quot; to post.getInt(&quot;user_id&quot;).toString(),&#10;                        &quot;item_name&quot; to post.getString(&quot;item_name&quot;),&#10;                        &quot;item_description&quot; to post.getString(&quot;item_description&quot;),&#10;                        &quot;location&quot; to post.getString(&quot;location&quot;),&#10;                        &quot;item_type&quot; to post.getString(&quot;item_type&quot;),&#10;                        &quot;item_image&quot; to post.optString(&quot;item_image&quot;, &quot;&quot;),&#10;                        &quot;status&quot; to post.optString(&quot;status&quot;, &quot;active&quot;),&#10;                        &quot;created_at&quot; to Timestamp.now(),&#10;                        &quot;updated_at&quot; to Timestamp.now(),&#10;                        &quot;sync_status&quot; to true&#10;                    )&#10;&#10;                    firestoreHelper.createPost(firebasePostData)&#10;&#10;                    // Add small delay to avoid overwhelming Firestore&#10;                    if (i % 10 == 0) {&#10;                        kotlinx.coroutines.delay(500)&#10;                    }&#10;                }&#10;&#10;                Log.d(TAG, &quot;Total posts migrated: ${postsArray.length()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error migrating posts: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/firebase/FirestoreHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/firebase/FirestoreHelper.kt" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application.firebase&#10;&#10;import android.util.Log&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import com.google.firebase.firestore.SetOptions&#10;import com.google.firebase.Timestamp&#10;import kotlinx.coroutines.tasks.await&#10;&#10;/**&#10; * Firebase Firestore Helper Class&#10; * Mirrors MySQL database structure in Firestore&#10; */&#10;class FirestoreHelper {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;&#10;    companion object {&#10;        private const val TAG = &quot;FirestoreHelper&quot;&#10;        &#10;        // Collection names matching MySQL tables&#10;        const val COLLECTION_USERS = &quot;users&quot;&#10;        const val COLLECTION_POSTS = &quot;posts&quot;&#10;        const val COLLECTION_NOTIFICATIONS = &quot;notifications&quot;&#10;        const val COLLECTION_USER_SESSIONS = &quot;user_sessions&quot;&#10;        const val COLLECTION_SEARCH_HISTORY = &quot;search_history&quot;&#10;        const val COLLECTION_CHAT_ROOMS = &quot;chat_rooms&quot;&#10;        const val COLLECTION_CHAT_MESSAGES = &quot;chat_messages&quot;&#10;    }&#10;&#10;    // ========================================&#10;    // USER OPERATIONS&#10;    // ========================================&#10;&#10;    suspend fun createUser(userData: Map&lt;String, Any&gt;): Boolean {&#10;        return try {&#10;            val userId = userData[&quot;user_id&quot;].toString()&#10;            db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .set(userData, SetOptions.merge())&#10;                .await()&#10;            Log.d(TAG, &quot;User created successfully: $userId&quot;)&#10;            true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error creating user: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    suspend fun getUserProfile(userId: String): Map&lt;String, Any&gt;? {&#10;        return try {&#10;            val document = db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .get()&#10;                .await()&#10;            &#10;            if (document.exists()) {&#10;                document.data&#10;            } else {&#10;                null&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting user profile: ${e.message}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun updateUserProfile(userId: String, updates: Map&lt;String, Any&gt;): Boolean {&#10;        return try {&#10;            val data = updates.toMutableMap()&#10;            data[&quot;updated_at&quot;] = Timestamp.now()&#10;            &#10;            db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .update(data)&#10;                .await()&#10;            Log.d(TAG, &quot;User profile updated: $userId&quot;)&#10;            true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error updating user profile: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    suspend fun updateFCMToken(userId: String, fcmToken: String): Boolean {&#10;        return try {&#10;            db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .update(&quot;fcm_token&quot;, fcmToken)&#10;                .await()&#10;            Log.d(TAG, &quot;FCM token updated for user: $userId&quot;)&#10;            true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error updating FCM token: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // POST OPERATIONS&#10;    // ========================================&#10;&#10;    suspend fun createPost(postData: Map&lt;String, Any&gt;): String? {&#10;        return try {&#10;            val postRef = db.collection(COLLECTION_POSTS).document()&#10;            val data = postData.toMutableMap()&#10;            data[&quot;created_at&quot;] = Timestamp.now()&#10;            data[&quot;updated_at&quot;] = Timestamp.now()&#10;            data[&quot;sync_status&quot;] = true&#10;            &#10;            postRef.set(data).await()&#10;            Log.d(TAG, &quot;Post created: ${postRef.id}&quot;)&#10;            postRef.id&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error creating post: ${e.message}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun getPosts(&#10;        itemType: String? = null,&#10;        status: String = &quot;active&quot;,&#10;        limit: Int = 50&#10;    ): List&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            var query: Query = db.collection(COLLECTION_POSTS)&#10;                .whereEqualTo(&quot;status&quot;, status)&#10;            &#10;            itemType?.let {&#10;                query = query.whereEqualTo(&quot;item_type&quot;, it)&#10;            }&#10;            &#10;            val documents = query&#10;                .orderBy(&quot;created_at&quot;, Query.Direction.DESCENDING)&#10;                .limit(limit.toLong())&#10;                .get()&#10;                .await()&#10;            &#10;            documents.documents.mapNotNull { it.data }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting posts: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    suspend fun getUserPosts(userId: String, status: String = &quot;active&quot;): List&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            val documents = db.collection(COLLECTION_POSTS)&#10;                .whereEqualTo(&quot;user_id&quot;, userId)&#10;                .whereEqualTo(&quot;status&quot;, status)&#10;                .orderBy(&quot;created_at&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .await()&#10;            &#10;            documents.documents.mapNotNull { it.data }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting user posts: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    suspend fun updatePost(postId: String, updates: Map&lt;String, Any&gt;): Boolean {&#10;        return try {&#10;            val data = updates.toMutableMap()&#10;            data[&quot;updated_at&quot;] = Timestamp.now()&#10;            &#10;            db.collection(COLLECTION_POSTS)&#10;                .document(postId)&#10;                .update(data)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error updating post: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    suspend fun deletePost(postId: String): Boolean {&#10;        return try {&#10;            db.collection(COLLECTION_POSTS)&#10;                .document(postId)&#10;                .update(&quot;status&quot;, &quot;deleted&quot;, &quot;updated_at&quot;, Timestamp.now())&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error deleting post: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // NOTIFICATION OPERATIONS&#10;    // ========================================&#10;&#10;    suspend fun createNotification(notificationData: Map&lt;String, Any&gt;): String? {&#10;        return try {&#10;            val notifRef = db.collection(COLLECTION_NOTIFICATIONS).document()&#10;            val data = notificationData.toMutableMap()&#10;            data[&quot;created_at&quot;] = Timestamp.now()&#10;            data[&quot;is_read&quot;] = false&#10;            &#10;            notifRef.set(data).await()&#10;            notifRef.id&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error creating notification: ${e.message}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun getUserNotifications(userId: String): List&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            val documents = db.collection(COLLECTION_NOTIFICATIONS)&#10;                .whereEqualTo(&quot;user_id&quot;, userId)&#10;                .orderBy(&quot;created_at&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .await()&#10;            &#10;            documents.documents.mapNotNull { it.data }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting notifications: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    suspend fun markNotificationAsRead(notificationId: String): Boolean {&#10;        return try {&#10;            db.collection(COLLECTION_NOTIFICATIONS)&#10;                .document(notificationId)&#10;                .update(&quot;is_read&quot;, true)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error marking notification as read: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // CHAT OPERATIONS&#10;    // ========================================&#10;&#10;    suspend fun createChatRoom(roomData: Map&lt;String, Any&gt;): String? {&#10;        return try {&#10;            // Check if room already exists&#10;            val existingRoom = db.collection(COLLECTION_CHAT_ROOMS)&#10;                .whereEqualTo(&quot;post_id&quot;, roomData[&quot;post_id&quot;])&#10;                .whereEqualTo(&quot;sender_id&quot;, roomData[&quot;sender_id&quot;])&#10;                .whereEqualTo(&quot;receiver_id&quot;, roomData[&quot;receiver_id&quot;])&#10;                .get()&#10;                .await()&#10;            &#10;            if (!existingRoom.isEmpty) {&#10;                return existingRoom.documents[0].id&#10;            }&#10;            &#10;            val roomRef = db.collection(COLLECTION_CHAT_ROOMS).document()&#10;            val data = roomData.toMutableMap()&#10;            data[&quot;created_at&quot;] = Timestamp.now()&#10;            data[&quot;updated_at&quot;] = Timestamp.now()&#10;            data[&quot;is_active&quot;] = true&#10;            &#10;            roomRef.set(data).await()&#10;            roomRef.id&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error creating chat room: ${e.message}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun getUserChatRooms(userId: String): List&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            // Get rooms where user is sender&#10;            val senderRooms = db.collection(COLLECTION_CHAT_ROOMS)&#10;                .whereEqualTo(&quot;sender_id&quot;, userId)&#10;                .whereEqualTo(&quot;is_active&quot;, true)&#10;                .get()&#10;                .await()&#10;            &#10;            // Get rooms where user is receiver&#10;            val receiverRooms = db.collection(COLLECTION_CHAT_ROOMS)&#10;                .whereEqualTo(&quot;receiver_id&quot;, userId)&#10;                .whereEqualTo(&quot;is_active&quot;, true)&#10;                .get()&#10;                .await()&#10;            &#10;            val allRooms = mutableListOf&lt;Map&lt;String, Any&gt;&gt;()&#10;            allRooms.addAll(senderRooms.documents.mapNotNull { it.data })&#10;            allRooms.addAll(receiverRooms.documents.mapNotNull { it.data })&#10;            &#10;            allRooms.sortedByDescending { &#10;                (it[&quot;updated_at&quot;] as? Timestamp)?.toDate()?.time ?: 0 &#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting chat rooms: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    suspend fun sendMessage(messageData: Map&lt;String, Any&gt;): String? {&#10;        return try {&#10;            val messageRef = db.collection(COLLECTION_CHAT_MESSAGES).document()&#10;            val data = messageData.toMutableMap()&#10;            data[&quot;created_at&quot;] = Timestamp.now()&#10;            data[&quot;is_read&quot;] = false&#10;            &#10;            messageRef.set(data).await()&#10;            &#10;            // Update chat room's updated_at&#10;            val roomId = messageData[&quot;room_id&quot;] as? String&#10;            roomId?.let {&#10;                db.collection(COLLECTION_CHAT_ROOMS)&#10;                    .document(it)&#10;                    .update(&#10;                        &quot;updated_at&quot;, Timestamp.now(),&#10;                        &quot;last_message&quot;, messageData[&quot;message_text&quot;]&#10;                    )&#10;                    .await()&#10;            }&#10;            &#10;            messageRef.id&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun getChatMessages(roomId: String, limit: Int = 100): List&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            val documents = db.collection(COLLECTION_CHAT_MESSAGES)&#10;                .whereEqualTo(&quot;room_id&quot;, roomId)&#10;                .orderBy(&quot;created_at&quot;, Query.Direction.ASCENDING)&#10;                .limit(limit.toLong())&#10;                .get()&#10;                .await()&#10;            &#10;            documents.documents.mapNotNull { it.data }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting chat messages: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    fun listenToChatMessages(&#10;        roomId: String,&#10;        onMessagesChanged: (List&lt;Map&lt;String, Any&gt;&gt;) -&gt; Unit&#10;    ) {&#10;        db.collection(COLLECTION_CHAT_MESSAGES)&#10;            .whereEqualTo(&quot;room_id&quot;, roomId)&#10;            .orderBy(&quot;created_at&quot;, Query.Direction.ASCENDING)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null) {&#10;                    Log.e(TAG, &quot;Error listening to messages: ${error.message}&quot;, error)&#10;                    return@addSnapshotListener&#10;                }&#10;                &#10;                val messages = snapshot?.documents?.mapNotNull { it.data } ?: emptyList()&#10;                onMessagesChanged(messages)&#10;            }&#10;    }&#10;&#10;    // ========================================&#10;    // SEARCH OPERATIONS&#10;    // ========================================&#10;&#10;    suspend fun addSearchHistory(userId: String, searchQuery: String, searchType: String): Boolean {&#10;        return try {&#10;            val searchRef = db.collection(COLLECTION_SEARCH_HISTORY).document()&#10;            val data = mapOf(&#10;                &quot;user_id&quot; to userId,&#10;                &quot;search_query&quot; to searchQuery,&#10;                &quot;search_type&quot; to searchType,&#10;                &quot;created_at&quot; to Timestamp.now()&#10;            )&#10;            &#10;            searchRef.set(data).await()&#10;            true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error adding search history: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    suspend fun searchPosts(&#10;        query: String,&#10;        itemType: String? = null,&#10;        status: String = &quot;active&quot;&#10;    ): List&lt;Map&lt;String, Any&gt;&gt; {&#10;        return try {&#10;            // Note: Firestore doesn't support full-text search&#10;            // You might want to use Algolia or similar service for better search&#10;            val allPosts = getPosts(itemType, status, 100)&#10;            &#10;            allPosts.filter { post -&gt;&#10;                val itemName = post[&quot;item_name&quot;] as? String ?: &quot;&quot;&#10;                val description = post[&quot;item_description&quot;] as? String ?: &quot;&quot;&#10;                val location = post[&quot;location&quot;] as? String ?: &quot;&quot;&#10;                &#10;                itemName.contains(query, ignoreCase = true) ||&#10;                description.contains(query, ignoreCase = true) ||&#10;                location.contains(query, ignoreCase = true)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error searching posts: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/repository/AuthRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/repository/AuthRepository.kt" />
              <option name="originalContent" value="package com.hamzatariq.lost_and_found_application.repository&#10;&#10;import android.util.Log&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.hamzatariq.lost_and_found_application.api.ApiService&#10;import com.hamzatariq.lost_and_found_application.api.AuthResponse&#10;import com.hamzatariq.lost_and_found_application.api.LoginRequest&#10;import com.hamzatariq.lost_and_found_application.api.SignupRequest&#10;import com.hamzatariq.lost_and_found_application.api.UserData&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class AuthRepository(&#10;    private val apiService: ApiService,&#10;    private val firebaseAuth: FirebaseAuth,&#10;    private val prefsManager: SharedPreferencesManager&#10;) {&#10;    &#10;    sealed class AuthResult {&#10;        data class Success(val userData: UserData) : AuthResult()&#10;        data class Error(val message: String) : AuthResult()&#10;        object Loading : AuthResult()&#10;    }&#10;    &#10;    suspend fun signup(&#10;        fullName: String,&#10;        username: String,&#10;        email: String,&#10;        mobileNumber: String,&#10;        password: String&#10;    ): AuthResult {&#10;        return try {&#10;            // First, create user in Firebase&#10;            firebaseAuth.createUserWithEmailAndPassword(email, password).await()&#10;            &#10;            // Then, register in MySQL via API&#10;            val signupRequest = SignupRequest(&#10;                full_name = fullName,&#10;                username = username,&#10;                email = email,&#10;                mobile_number = mobileNumber,&#10;                password = password&#10;            )&#10;            &#10;            val response = apiService.signup(signupRequest)&#10;            &#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val userData = response.body()?.data&#10;                if (userData != null) {&#10;                    // Save token and user data locally&#10;                    saveAuthToken(userData.token)&#10;                    saveUserData(userData)&#10;                    AuthResult.Success(userData)&#10;                } else {&#10;                    AuthResult.Error(&quot;Invalid response data&quot;)&#10;                }&#10;            } else {&#10;                AuthResult.Error(response.body()?.message ?: &quot;Signup failed&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Signup error: ${e.message}&quot;)&#10;            AuthResult.Error(e.message ?: &quot;Unknown error occurred&quot;)&#10;        }&#10;    }&#10;    &#10;    suspend fun login(&#10;        username: String,&#10;        password: String&#10;    ): AuthResult {&#10;        return try {&#10;            // First, try to login with MySQL API&#10;            val loginRequest = LoginRequest(&#10;                username = username,&#10;                password = password&#10;            )&#10;            &#10;            val response = apiService.login(loginRequest)&#10;            &#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val userData = response.body()?.data&#10;                if (userData != null) {&#10;                    // Try to login with Firebase using email&#10;                    try {&#10;                        firebaseAuth.signInWithEmailAndPassword(userData.email, password).await()&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;AuthRepository&quot;, &quot;Firebase login failed: ${e.message}&quot;)&#10;                        // Continue anyway, MySQL auth is successful&#10;                    }&#10;                    &#10;                    // Save token and user data locally&#10;                    saveAuthToken(userData.token)&#10;                    saveUserData(userData)&#10;                    AuthResult.Success(userData)&#10;                } else {&#10;                    AuthResult.Error(&quot;Invalid response data&quot;)&#10;                }&#10;            } else {&#10;                AuthResult.Error(response.body()?.message ?: &quot;Login failed&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Login error: ${e.message}&quot;)&#10;            AuthResult.Error(e.message ?: &quot;Unknown error occurred&quot;)&#10;        }&#10;    }&#10;    &#10;    fun logout() {&#10;        firebaseAuth.signOut()&#10;        clearAuthToken()&#10;    }&#10;    &#10;    fun isUserLoggedIn(): Boolean {&#10;        return getAuthToken() != null &amp;&amp; firebaseAuth.currentUser != null&#10;    }&#10;    &#10;    fun getCurrentUser() = firebaseAuth.currentUser&#10;    &#10;    private fun saveAuthToken(token: String) {&#10;        prefsManager.saveAuthToken(token)&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Token saved&quot;)&#10;    }&#10;    &#10;    private fun getAuthToken(): String? {&#10;        return prefsManager.getAuthToken()&#10;    }&#10;    &#10;    private fun saveUserData(userData: UserData) {&#10;        prefsManager.saveUserData(&#10;            userData.user_id,&#10;            userData.username,&#10;            userData.email,&#10;            userData.full_name,&#10;            userData.mobile_number&#10;        )&#10;        Log.d(&quot;AuthRepository&quot;, &quot;User data saved&quot;)&#10;    }&#10;    &#10;    private fun clearAuthToken() {&#10;        prefsManager.clearAll()&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Token and user data cleared&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application.repository&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.util.Log&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.hamzatariq.lost_and_found_application.api.ApiService&#13;&#10;import com.hamzatariq.lost_and_found_application.api.AuthResponse&#13;&#10;import com.hamzatariq.lost_and_found_application.api.LoginRequest&#13;&#10;import com.hamzatariq.lost_and_found_application.api.SignupRequest&#13;&#10;import com.hamzatariq.lost_and_found_application.api.UserData&#13;&#10;import com.hamzatariq.lost_and_found_application.firebase.DataSyncService&#13;&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;&#13;&#10;class AuthRepository(&#13;&#10;    private val apiService: ApiService,&#13;&#10;    private val firebaseAuth: FirebaseAuth,&#13;&#10;    private val prefsManager: SharedPreferencesManager,&#13;&#10;    private val context: Context&#13;&#10;) {&#13;&#10;    &#13;&#10;    private val dataSyncService = DataSyncService(context)&#13;&#10;    &#13;&#10;    sealed class AuthResult {&#13;&#10;        data class Success(val userData: UserData) : AuthResult()&#13;&#10;        data class Error(val message: String) : AuthResult()&#13;&#10;        object Loading : AuthResult()&#13;&#10;    }&#13;&#10;    &#13;&#10;    suspend fun signup(&#13;&#10;        fullName: String,&#13;&#10;        username: String,&#13;&#10;        email: String,&#13;&#10;        mobileNumber: String,&#13;&#10;        password: String&#13;&#10;    ): AuthResult {&#13;&#10;        return try {&#13;&#10;            // First, create user in Firebase&#13;&#10;            firebaseAuth.createUserWithEmailAndPassword(email, password).await()&#13;&#10;            &#13;&#10;            // Then, register in MySQL via API&#13;&#10;            val signupRequest = SignupRequest(&#13;&#10;                full_name = fullName,&#13;&#10;                username = username,&#13;&#10;                email = email,&#13;&#10;                mobile_number = mobileNumber,&#13;&#10;                password = password&#13;&#10;            )&#13;&#10;            &#13;&#10;            val response = apiService.signup(signupRequest)&#13;&#10;            &#13;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#13;&#10;                val userData = response.body()?.data&#13;&#10;                if (userData != null) {&#13;&#10;                    // Save token and user data locally&#13;&#10;                    saveAuthToken(userData.token)&#13;&#10;                    saveUserData(userData)&#13;&#10;                    &#13;&#10;                    // Sync user data to Firebase Firestore&#13;&#10;                    dataSyncService.syncUserToFirebase(userData.user_id)&#13;&#10;                    Log.d(&quot;AuthRepository&quot;, &quot;User synced to Firebase after signup&quot;)&#13;&#10;                    &#13;&#10;                    AuthResult.Success(userData)&#13;&#10;                } else {&#13;&#10;                    AuthResult.Error(&quot;Invalid response data&quot;)&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                AuthResult.Error(response.body()?.message ?: &quot;Signup failed&quot;)&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Signup error: ${e.message}&quot;)&#13;&#10;            AuthResult.Error(e.message ?: &quot;Unknown error occurred&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    suspend fun login(&#13;&#10;        username: String,&#13;&#10;        password: String&#13;&#10;    ): AuthResult {&#13;&#10;        return try {&#13;&#10;            // First, try to login with MySQL API&#13;&#10;            val loginRequest = LoginRequest(&#13;&#10;                username = username,&#13;&#10;                password = password&#13;&#10;            )&#13;&#10;            &#13;&#10;            val response = apiService.login(loginRequest)&#13;&#10;            &#13;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#13;&#10;                val userData = response.body()?.data&#13;&#10;                if (userData != null) {&#13;&#10;                    // Try to login with Firebase using email&#13;&#10;                    try {&#13;&#10;                        firebaseAuth.signInWithEmailAndPassword(userData.email, password).await()&#13;&#10;                    } catch (e: Exception) {&#13;&#10;                        Log.w(&quot;AuthRepository&quot;, &quot;Firebase login failed: ${e.message}&quot;)&#13;&#10;                        // Continue anyway, MySQL auth is successful&#13;&#10;                    }&#13;&#10;                    &#13;&#10;                    // Save token and user data locally&#13;&#10;                    saveAuthToken(userData.token)&#13;&#10;                    saveUserData(userData)&#13;&#10;                    &#13;&#10;                    // Sync user data to Firebase Firestore&#13;&#10;                    dataSyncService.syncUserToFirebase(userData.user_id)&#13;&#10;                    Log.d(&quot;AuthRepository&quot;, &quot;User synced to Firebase after login&quot;)&#13;&#10;                    &#13;&#10;                    AuthResult.Success(userData)&#13;&#10;                } else {&#13;&#10;                    AuthResult.Error(&quot;Invalid response data&quot;)&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                AuthResult.Error(response.body()?.message ?: &quot;Login failed&quot;)&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Login error: ${e.message}&quot;)&#13;&#10;            AuthResult.Error(e.message ?: &quot;Unknown error occurred&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    fun logout() {&#13;&#10;        firebaseAuth.signOut()&#13;&#10;        clearAuthToken()&#13;&#10;    }&#13;&#10;    &#13;&#10;    fun isUserLoggedIn(): Boolean {&#13;&#10;        return getAuthToken() != null &amp;&amp; firebaseAuth.currentUser != null&#13;&#10;    }&#13;&#10;    &#13;&#10;    fun getCurrentUser() = firebaseAuth.currentUser&#13;&#10;    &#13;&#10;    private fun saveAuthToken(token: String) {&#13;&#10;        prefsManager.saveAuthToken(token)&#13;&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Token saved&quot;)&#13;&#10;    }&#13;&#10;    &#13;&#10;    private fun getAuthToken(): String? {&#13;&#10;        return prefsManager.getAuthToken()&#13;&#10;    }&#13;&#10;    &#13;&#10;    private fun saveUserData(userData: UserData) {&#13;&#10;        prefsManager.saveUserData(&#13;&#10;            userData.user_id,&#13;&#10;            userData.username,&#13;&#10;            userData.email,&#13;&#10;            userData.full_name,&#13;&#10;            userData.mobile_number&#13;&#10;        )&#13;&#10;        Log.d(&quot;AuthRepository&quot;, &quot;User data saved&quot;)&#13;&#10;    }&#13;&#10;    &#13;&#10;    private fun clearAuthToken() {&#13;&#10;        prefsManager.clearAll()&#13;&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Token and user data cleared&quot;)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/repository/PostRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/repository/PostRepository.kt" />
              <option name="originalContent" value="package com.hamzatariq.lost_and_found_application.repository&#10;&#10;import android.util.Log&#10;import com.hamzatariq.lost_and_found_application.api.ApiService&#10;import com.hamzatariq.lost_and_found_application.api.CreatePostRequest&#10;import com.hamzatariq.lost_and_found_application.api.Post&#10;import com.hamzatariq.lost_and_found_application.api.PostData&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#10;&#10;class PostRepository(&#10;    private val apiService: ApiService,&#10;    private val prefsManager: SharedPreferencesManager&#10;) {&#10;&#10;    sealed class PostResult {&#10;        data class Success(val postData: PostData) : PostResult()&#10;        data class Error(val message: String) : PostResult()&#10;        object Loading : PostResult()&#10;    }&#10;&#10;    sealed class PostsListResult {&#10;        data class Success(val posts: List&lt;Post&gt;) : PostsListResult()&#10;        data class Error(val message: String) : PostsListResult()&#10;        object Loading : PostsListResult()&#10;    }&#10;&#10;    suspend fun createPost(&#10;        itemName: String,&#10;        itemDescription: String,&#10;        location: String,&#10;        itemType: String,&#10;        imageBase64: String?&#10;    ): PostResult {&#10;        return try {&#10;            val token = prefsManager.getAuthToken()&#10;            if (token.isNullOrEmpty()) {&#10;                return PostResult.Error(&quot;Authentication required&quot;)&#10;            }&#10;&#10;            val request = CreatePostRequest(&#10;                item_name = itemName,&#10;                item_description = itemDescription,&#10;                location = location,&#10;                item_type = itemType,&#10;                item_image_base64 = imageBase64&#10;            )&#10;&#10;            val response = apiService.createPost(&quot;Bearer $token&quot;, request)&#10;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val postData = response.body()?.data&#10;                if (postData != null) {&#10;                    PostResult.Success(postData)&#10;                } else {&#10;                    PostResult.Error(&quot;Invalid response data&quot;)&#10;                }&#10;            } else {&#10;                PostResult.Error(response.body()?.message ?: &quot;Failed to create post&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PostRepository&quot;, &quot;Create post error: ${e.message}&quot;)&#10;            PostResult.Error(e.message ?: &quot;Unknown error occurred&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun getPosts(&#10;        itemType: String? = null,&#10;        searchQuery: String? = null&#10;    ): PostsListResult {&#10;        return try {&#10;            val response = apiService.getPosts(&#10;                itemType = itemType,&#10;                search = searchQuery,&#10;                limit = 50,&#10;                offset = 0&#10;            )&#10;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val posts = response.body()?.data ?: emptyList()&#10;                PostsListResult.Success(posts)&#10;            } else {&#10;                PostsListResult.Error(&quot;Failed to fetch posts&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PostRepository&quot;, &quot;Get posts error: ${e.message}&quot;)&#10;            PostsListResult.Error(e.message ?: &quot;Unknown error occurred&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application.repository&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.util.Log&#13;&#10;import com.hamzatariq.lost_and_found_application.api.ApiService&#13;&#10;import com.hamzatariq.lost_and_found_application.api.CreatePostRequest&#13;&#10;import com.hamzatariq.lost_and_found_application.api.Post&#13;&#10;import com.hamzatariq.lost_and_found_application.api.PostData&#13;&#10;import com.hamzatariq.lost_and_found_application.firebase.DataSyncService&#13;&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#13;&#10;&#13;&#10;class PostRepository(&#13;&#10;    private val apiService: ApiService,&#13;&#10;    private val prefsManager: SharedPreferencesManager,&#13;&#10;    private val context: Context&#13;&#10;) {&#13;&#10;&#13;&#10;    private val dataSyncService = DataSyncService(context)&#13;&#10;&#13;&#10;    sealed class PostResult {&#13;&#10;        data class Success(val postData: PostData) : PostResult()&#13;&#10;        data class Error(val message: String) : PostResult()&#13;&#10;        object Loading : PostResult()&#13;&#10;    }&#13;&#10;&#13;&#10;    sealed class PostsListResult {&#13;&#10;        data class Success(val posts: List&lt;Post&gt;) : PostsListResult()&#13;&#10;        data class Error(val message: String) : PostsListResult()&#13;&#10;        object Loading : PostsListResult()&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun createPost(&#13;&#10;        itemName: String,&#13;&#10;        itemDescription: String,&#13;&#10;        location: String,&#13;&#10;        itemType: String,&#13;&#10;        imageBase64: String?&#13;&#10;    ): PostResult {&#13;&#10;        return try {&#13;&#10;            val token = prefsManager.getAuthToken()&#13;&#10;            if (token.isNullOrEmpty()) {&#13;&#10;                return PostResult.Error(&quot;Authentication required&quot;)&#13;&#10;            }&#13;&#10;&#13;&#10;            val request = CreatePostRequest(&#13;&#10;                item_name = itemName,&#13;&#10;                item_description = itemDescription,&#13;&#10;                location = location,&#13;&#10;                item_type = itemType,&#13;&#10;                item_image_base64 = imageBase64&#13;&#10;            )&#13;&#10;&#13;&#10;            val response = apiService.createPost(&quot;Bearer $token&quot;, request)&#13;&#10;&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#13;&#10;                val postData = response.body()?.data&#13;&#10;                if (postData != null) {&#13;&#10;                    // Sync posts to Firebase after successful creation&#13;&#10;                    val userId = prefsManager.getUserId()&#13;&#10;                    if (userId != -1) {&#13;&#10;                        dataSyncService.syncPostsToFirebase(userId)&#13;&#10;                        Log.d(&quot;PostRepository&quot;, &quot;Post synced to Firebase&quot;)&#13;&#10;                    }&#13;&#10;                    &#13;&#10;                    PostResult.Success(postData)&#13;&#10;                } else {&#13;&#10;                    PostResult.Error(&quot;Invalid response data&quot;)&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                PostResult.Error(response.body()?.message ?: &quot;Failed to create post&quot;)&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;PostRepository&quot;, &quot;Create post error: ${e.message}&quot;)&#13;&#10;            PostResult.Error(e.message ?: &quot;Unknown error occurred&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun getPosts(&#13;&#10;        itemType: String? = null,&#13;&#10;        searchQuery: String? = null&#13;&#10;    ): PostsListResult {&#13;&#10;        return try {&#13;&#10;            val response = apiService.getPosts(&#13;&#10;                itemType = itemType,&#13;&#10;                search = searchQuery,&#13;&#10;                limit = 50,&#13;&#10;                offset = 0&#13;&#10;            )&#13;&#10;&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#13;&#10;                val posts = response.body()?.data ?: emptyList()&#13;&#10;                PostsListResult.Success(posts)&#13;&#10;            } else {&#13;&#10;                PostsListResult.Error(&quot;Failed to fetch posts&quot;)&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;PostRepository&quot;, &quot;Get posts error: ${e.message}&quot;)&#13;&#10;            PostsListResult.Error(e.message ?: &quot;Unknown error occurred&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/viewmodel/AuthViewModelFactory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/viewmodel/AuthViewModelFactory.kt" />
              <option name="originalContent" value="package com.hamzatariq.lost_and_found_application.viewmodel&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.hamzatariq.lost_and_found_application.api.RetrofitClient&#10;import com.hamzatariq.lost_and_found_application.repository.AuthRepository&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#10;&#10;class AuthViewModelFactory(private val context: Context) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(AuthViewModel::class.java)) {&#10;            val authRepository = AuthRepository(&#10;                RetrofitClient.apiService,&#10;                FirebaseAuth.getInstance(),&#10;                SharedPreferencesManager(context)&#10;            )&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return AuthViewModel(authRepository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application.viewmodel&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.ViewModelProvider&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.hamzatariq.lost_and_found_application.api.RetrofitClient&#13;&#10;import com.hamzatariq.lost_and_found_application.repository.AuthRepository&#13;&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#13;&#10;&#13;&#10;class AuthViewModelFactory(private val context: Context) : ViewModelProvider.Factory {&#13;&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#13;&#10;        if (modelClass.isAssignableFrom(AuthViewModel::class.java)) {&#13;&#10;            val authRepository = AuthRepository(&#13;&#10;                RetrofitClient.apiService,&#13;&#10;                FirebaseAuth.getInstance(),&#13;&#10;                SharedPreferencesManager(context),&#13;&#10;                context&#13;&#10;            )&#13;&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#13;&#10;            return AuthViewModel(authRepository) as T&#13;&#10;        }&#13;&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/viewmodel/PostViewModelFactory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/lost_and_found_application/viewmodel/PostViewModelFactory.kt" />
              <option name="originalContent" value="package com.hamzatariq.lost_and_found_application.viewmodel&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.hamzatariq.lost_and_found_application.api.RetrofitClient&#10;import com.hamzatariq.lost_and_found_application.repository.PostRepository&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#10;&#10;class PostViewModelFactory(private val context: Context) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(PostViewModel::class.java)) {&#10;            val apiService = RetrofitClient.apiService&#10;            val prefsManager = SharedPreferencesManager(context)&#10;            val repository = PostRepository(apiService, prefsManager)&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return PostViewModel(repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.lost_and_found_application.viewmodel&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.ViewModelProvider&#13;&#10;import com.hamzatariq.lost_and_found_application.api.RetrofitClient&#13;&#10;import com.hamzatariq.lost_and_found_application.repository.PostRepository&#13;&#10;import com.hamzatariq.lost_and_found_application.utils.SharedPreferencesManager&#13;&#10;&#13;&#10;class PostViewModelFactory(private val context: Context) : ViewModelProvider.Factory {&#13;&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#13;&#10;        if (modelClass.isAssignableFrom(PostViewModel::class.java)) {&#13;&#10;            val apiService = RetrofitClient.apiService&#13;&#10;            val prefsManager = SharedPreferencesManager(context)&#13;&#10;            val repository = PostRepository(apiService, prefsManager, context)&#13;&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#13;&#10;            return PostViewModel(repository) as T&#13;&#10;        }&#13;&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>